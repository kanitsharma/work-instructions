webpackJsonp([2,5],{"+JOu":function(n,e){n.exports='/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e="DEPRECATED METHOD: "+c+"\\n"+d+" AT \\n";return function(){var c=new Error("get-stack-trace"),d=c&&c.stack?c.stack.replace(/^[^\\(]+?[\\n$]/gm,"").replace(/^\\s+at\\s+/gm,"").replace(/^Object.<anonymous>\\s*\\(/gm,"{anonymous}()@"):"Unknown Stack Trace",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),"identifier",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),"identifier",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(d){b[d]=c?a.CSS.supports("touch-action",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?"cancel":a&qb?"end":a&pb?"move":a&ob?"start":""}function $(a){return a==Ma?"down":a==La?"up":a==Ja?"left":a==Ka?"right":""}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||""}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=["","webkit","Moz","MS","ms","o"],na=b.createElement("div"),oa="function",pa=Math.round,qa=Math.abs,ra=Date.now;la="function"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},"extend","Use `assign`."),ta=h(function(a,b){return sa(a,b,!0)},"merge","Use `assign`."),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa="ontouchstart"in a,xa=u(a,"PointerEvent")!==d,ya=wa&&va.test(navigator.userAgent),za="touch",Aa="pen",Ba="mouse",Ca="kinect",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=["x","y"],Ra=["clientX","clientY"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta="mousedown",Ua="mousemove mouseup";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa="pointerdown",Ya="pointermove pointerup pointercancel";a.MSPointerEvent&&!a.PointerEvent&&(Xa="MSPointerDown",Ya="MSPointerMove MSPointerUp MSPointerCancel"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,"pointerId");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a="touchstart",_a="touchstart touchmove touchend touchcancel";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb="touchstart touchmove touchend touchcancel";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,"touchAction"),fb=eb!==d,gb="compute",hb="auto",ib="manipulation",jb="none",kb="pan-x",lb="pan-y",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(" "))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:"pan",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?"in":"out";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION="2.0.7",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},["rotate"]],[fa,{direction:Na}],[ba,{direction:Na},["swipe"]],[ga],[ga,{event:"doubletap",taps:2},["tap"]],[da]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb="undefined"!=typeof a?a:"undefined"!=typeof self?self:{};wb.Hammer=ha,"function"==typeof define&&define.amd?define(function(){return ha}):"undefined"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,"Hammer");\n//# sourceMappingURL=hammer.min.js.map'},3:function(n,e,t){t("yQ/E"),n.exports=t("JPcO")},"4Cf4":function(n,e){n.exports="(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.LC = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shallowEqual\n * @typechecks\n *\n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  var bHasOwnProperty = hasOwnProperty.bind(objB);\n  for (var i = 0; i < keysA.length; i++) {\n    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;\n},{}],2:[function(require,module,exports){\nmodule.exports = require('react/lib/ReactComponentWithPureRenderMixin');\n},{\"react/lib/ReactComponentWithPureRenderMixin\":3}],3:[function(require,module,exports){\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponentWithPureRenderMixin\n */\n\n'use strict';\n\nvar shallowCompare = require('./shallowCompare');\n\n/**\n * If your React component's render function is \"pure\", e.g. it will render the\n * same result given the same props and state, provide this Mixin for a\n * considerable performance boost.\n *\n * Most React components have pure render functions.\n *\n * Example:\n *\n *   var ReactComponentWithPureRenderMixin =\n *     require('ReactComponentWithPureRenderMixin');\n *   React.createClass({\n *     mixins: [ReactComponentWithPureRenderMixin],\n *\n *     render: function() {\n *       return <div className={this.props.className}>foo</div>;\n *     }\n *   });\n *\n * Note: This only checks shallow equality for props and state. If these contain\n * complex data structures this mixin may have false-negatives for deeper\n * differences. Only mixin to components which have simple props and state, or\n * use `forceUpdate()` when you know deep data structures have changed.\n */\nvar ReactComponentWithPureRenderMixin = {\n  shouldComponentUpdate: function (nextProps, nextState) {\n    return shallowCompare(this, nextProps, nextState);\n  }\n};\n\nmodule.exports = ReactComponentWithPureRenderMixin;\n},{\"./shallowCompare\":4}],4:[function(require,module,exports){\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule shallowCompare\n*/\n\n'use strict';\n\nvar shallowEqual = require('fbjs/lib/shallowEqual');\n\n/**\n * Does a shallow comparison for props and state.\n * See ReactComponentWithPureRenderMixin\n */\nfunction shallowCompare(instance, nextProps, nextState) {\n  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);\n}\n\nmodule.exports = shallowCompare;\n},{\"fbjs/lib/shallowEqual\":1}],5:[function(require,module,exports){\nvar INFINITE, JSONToShape, LiterallyCanvas, Pencil, actions, bindEvents, createShape, math, ref, renderShapeToContext, renderShapeToSVG, renderSnapshotToImage, renderSnapshotToSVG, shapeToJSON, util,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  slice = [].slice,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nactions = require('./actions');\n\nbindEvents = require('./bindEvents');\n\nmath = require('./math');\n\nref = require('./shapes'), createShape = ref.createShape, shapeToJSON = ref.shapeToJSON, JSONToShape = ref.JSONToShape;\n\nrenderShapeToContext = require('./canvasRenderer').renderShapeToContext;\n\nrenderShapeToSVG = require('./svgRenderer').renderShapeToSVG;\n\nrenderSnapshotToImage = require('./renderSnapshotToImage');\n\nrenderSnapshotToSVG = require('./renderSnapshotToSVG');\n\nPencil = require('../tools/Pencil');\n\nutil = require('./util');\n\nINFINITE = 'infinite';\n\nmodule.exports = LiterallyCanvas = (function() {\n  function LiterallyCanvas(arg1, arg2) {\n    this.setImageSize = bind(this.setImageSize, this);\n    var containerEl, opts;\n    opts = null;\n    containerEl = null;\n    if (arg1 instanceof HTMLElement) {\n      containerEl = arg1;\n      opts = arg2;\n    } else {\n      opts = arg1;\n    }\n    this.opts = opts || {};\n    this.config = {\n      zoomMin: opts.zoomMin || 0.2,\n      zoomMax: opts.zoomMax || 4.0,\n      zoomStep: opts.zoomStep || 0.2\n    };\n    this.colors = {\n      primary: opts.primaryColor || '#000',\n      secondary: opts.secondaryColor || '#fff',\n      background: opts.backgroundColor || 'transparent'\n    };\n    this.watermarkImage = opts.watermarkImage;\n    this.watermarkScale = opts.watermarkScale || 1;\n    this.backgroundCanvas = document.createElement('canvas');\n    this.backgroundCtx = this.backgroundCanvas.getContext('2d');\n    this.canvas = document.createElement('canvas');\n    this.canvas.style['background-color'] = 'transparent';\n    this.buffer = document.createElement('canvas');\n    this.buffer.style['background-color'] = 'transparent';\n    this.ctx = this.canvas.getContext('2d');\n    this.bufferCtx = this.buffer.getContext('2d');\n    this.backingScale = util.getBackingScale(this.ctx);\n    this.backgroundShapes = opts.backgroundShapes || [];\n    this._shapesInProgress = [];\n    this.shapes = [];\n    this.undoStack = [];\n    this.redoStack = [];\n    this.isDragging = false;\n    this.position = {\n      x: 0,\n      y: 0\n    };\n    this.scale = 1.0;\n    this.setTool(new this.opts.tools[0](this));\n    this.width = opts.imageSize.width || INFINITE;\n    this.height = opts.imageSize.height || INFINITE;\n    this.setZoom(this.scale);\n    if (opts.snapshot) {\n      this.loadSnapshot(opts.snapshot);\n    }\n    this.isBound = false;\n    if (containerEl) {\n      this.bindToElement(containerEl);\n    }\n    this.respondToSizeChange = function() {};\n  }\n\n  LiterallyCanvas.prototype.bindToElement = function(containerEl) {\n    var ref1, repaintAll;\n    if (this.containerEl) {\n      console.warn(\"Trying to bind Literally Canvas to a DOM element more than once is unsupported.\");\n      return;\n    }\n    this.containerEl = containerEl;\n    this._unsubscribeEvents = bindEvents(this, this.containerEl, this.opts.keyboardShortcuts);\n    this.containerEl.style['background-color'] = this.colors.background;\n    this.containerEl.appendChild(this.backgroundCanvas);\n    this.containerEl.appendChild(this.canvas);\n    this.isBound = true;\n    repaintAll = (function(_this) {\n      return function() {\n        _this.keepPanInImageBounds();\n        return _this.repaintAllLayers();\n      };\n    })(this);\n    this.respondToSizeChange = util.matchElementSize(this.containerEl, [this.backgroundCanvas, this.canvas], this.backingScale, repaintAll);\n    if (this.watermarkImage) {\n      this.watermarkImage.onload = (function(_this) {\n        return function() {\n          return _this.repaintLayer('background');\n        };\n      })(this);\n    }\n    if ((ref1 = this.tool) != null) {\n      ref1.didBecomeActive(this);\n    }\n    return repaintAll();\n  };\n\n  LiterallyCanvas.prototype._teardown = function() {\n    var ref1;\n    if ((ref1 = this.tool) != null) {\n      ref1.willBecomeInactive(this);\n    }\n    if (typeof this._unsubscribeEvents === \"function\") {\n      this._unsubscribeEvents();\n    }\n    this.tool = null;\n    this.containerEl = null;\n    return this.isBound = false;\n  };\n\n  LiterallyCanvas.prototype.trigger = function(name, data) {\n    this.canvas.dispatchEvent(new CustomEvent(name, {\n      detail: data\n    }));\n    return null;\n  };\n\n  LiterallyCanvas.prototype.on = function(name, fn) {\n    var wrapper;\n    wrapper = function(e) {\n      return fn(e.detail);\n    };\n    this.canvas.addEventListener(name, wrapper);\n    return (function(_this) {\n      return function() {\n        return _this.canvas.removeEventListener(name, wrapper);\n      };\n    })(this);\n  };\n\n  LiterallyCanvas.prototype.getRenderScale = function() {\n    return this.scale * this.backingScale;\n  };\n\n  LiterallyCanvas.prototype.clientCoordsToDrawingCoords = function(x, y) {\n    return {\n      x: (x * this.backingScale - this.position.x) / this.getRenderScale(),\n      y: (y * this.backingScale - this.position.y) / this.getRenderScale()\n    };\n  };\n\n  LiterallyCanvas.prototype.drawingCoordsToClientCoords = function(x, y) {\n    return {\n      x: x * this.getRenderScale() + this.position.x,\n      y: y * this.getRenderScale() + this.position.y\n    };\n  };\n\n  LiterallyCanvas.prototype.setImageSize = function(width, height) {\n    this.width = width || INFINITE;\n    this.height = height || INFINITE;\n    this.keepPanInImageBounds();\n    this.repaintAllLayers();\n    return this.trigger('imageSizeChange', {\n      width: this.width,\n      height: this.height\n    });\n  };\n\n  LiterallyCanvas.prototype.setTool = function(tool) {\n    var ref1;\n    if (this.isBound) {\n      if ((ref1 = this.tool) != null) {\n        ref1.willBecomeInactive(this);\n      }\n    }\n    this.tool = tool;\n    this.trigger('toolChange', {\n      tool: tool\n    });\n    if (this.isBound) {\n      return this.tool.didBecomeActive(this);\n    }\n  };\n\n  LiterallyCanvas.prototype.setShapesInProgress = function(newVal) {\n    return this._shapesInProgress = newVal;\n  };\n\n  LiterallyCanvas.prototype.pointerDown = function(x, y) {\n    var p;\n    p = this.clientCoordsToDrawingCoords(x, y);\n    if (this.tool.usesSimpleAPI) {\n      this.tool.begin(p.x, p.y, this);\n      this.isDragging = true;\n      return this.trigger(\"drawStart\", {\n        tool: this.tool\n      });\n    } else {\n      this.isDragging = true;\n      return this.trigger(\"lc-pointerdown\", {\n        tool: this.tool,\n        x: p.x,\n        y: p.y,\n        rawX: x,\n        rawY: y\n      });\n    }\n  };\n\n  LiterallyCanvas.prototype.pointerMove = function(x, y) {\n    return util.requestAnimationFrame((function(_this) {\n      return function() {\n        var p, ref1;\n        p = _this.clientCoordsToDrawingCoords(x, y);\n        if ((ref1 = _this.tool) != null ? ref1.usesSimpleAPI : void 0) {\n          if (_this.isDragging) {\n            _this.tool[\"continue\"](p.x, p.y, _this);\n            return _this.trigger(\"drawContinue\", {\n              tool: _this.tool\n            });\n          }\n        } else {\n          if (_this.isDragging) {\n            return _this.trigger(\"lc-pointerdrag\", {\n              tool: _this.tool,\n              x: p.x,\n              y: p.y,\n              rawX: x,\n              rawY: y\n            });\n          } else {\n            return _this.trigger(\"lc-pointermove\", {\n              tool: _this.tool,\n              x: p.x,\n              y: p.y,\n              rawX: x,\n              rawY: y\n            });\n          }\n        }\n      };\n    })(this));\n  };\n\n  LiterallyCanvas.prototype.pointerUp = function(x, y) {\n    var p;\n    p = this.clientCoordsToDrawingCoords(x, y);\n    if (this.tool.usesSimpleAPI) {\n      if (this.isDragging) {\n        this.tool.end(p.x, p.y, this);\n        this.isDragging = false;\n        return this.trigger(\"drawEnd\", {\n          tool: this.tool\n        });\n      }\n    } else {\n      this.isDragging = false;\n      return this.trigger(\"lc-pointerup\", {\n        tool: this.tool,\n        x: p.x,\n        y: p.y,\n        rawX: x,\n        rawY: y\n      });\n    }\n  };\n\n  LiterallyCanvas.prototype.setColor = function(name, color) {\n    this.colors[name] = color;\n    if (!this.isBound) {\n      return;\n    }\n    switch (name) {\n      case 'background':\n        this.containerEl.style.backgroundColor = this.colors.background;\n        this.repaintLayer('background');\n        break;\n      case 'primary':\n        this.repaintLayer('main');\n        break;\n      case 'secondary':\n        this.repaintLayer('main');\n    }\n    this.trigger(name + \"ColorChange\", this.colors[name]);\n    if (name === 'background') {\n      return this.trigger(\"drawingChange\");\n    }\n  };\n\n  LiterallyCanvas.prototype.getColor = function(name) {\n    return this.colors[name];\n  };\n\n  LiterallyCanvas.prototype.saveShape = function(shape, triggerShapeSaveEvent, previousShapeId) {\n    if (triggerShapeSaveEvent == null) {\n      triggerShapeSaveEvent = true;\n    }\n    if (previousShapeId == null) {\n      previousShapeId = null;\n    }\n    if (!previousShapeId) {\n      previousShapeId = this.shapes.length ? this.shapes[this.shapes.length - 1].id : null;\n    }\n    this.execute(new actions.AddShapeAction(this, shape, previousShapeId));\n    if (triggerShapeSaveEvent) {\n      this.trigger('shapeSave', {\n        shape: shape,\n        previousShapeId: previousShapeId\n      });\n    }\n    return this.trigger('drawingChange');\n  };\n\n  LiterallyCanvas.prototype.pan = function(x, y) {\n    return this.setPan(this.position.x - x, this.position.y - y);\n  };\n\n  LiterallyCanvas.prototype.keepPanInImageBounds = function() {\n    var ref1, renderScale, x, y;\n    renderScale = this.getRenderScale();\n    ref1 = this.position, x = ref1.x, y = ref1.y;\n    if (this.width !== INFINITE) {\n      if (this.canvas.width > this.width * renderScale) {\n        x = (this.canvas.width - this.width * renderScale) / 2;\n      } else {\n        x = Math.max(Math.min(0, x), this.canvas.width - this.width * renderScale);\n      }\n    }\n    if (this.height !== INFINITE) {\n      if (this.canvas.height > this.height * renderScale) {\n        y = (this.canvas.height - this.height * renderScale) / 2;\n      } else {\n        y = Math.max(Math.min(0, y), this.canvas.height - this.height * renderScale);\n      }\n    }\n    return this.position = {\n      x: x,\n      y: y\n    };\n  };\n\n  LiterallyCanvas.prototype.setPan = function(x, y) {\n    this.position = {\n      x: x,\n      y: y\n    };\n    this.keepPanInImageBounds();\n    this.repaintAllLayers();\n    return this.trigger('pan', {\n      x: this.position.x,\n      y: this.position.y\n    });\n  };\n\n  LiterallyCanvas.prototype.zoom = function(factor) {\n    var newScale;\n    newScale = this.scale + factor;\n    newScale = Math.max(newScale, this.config.zoomMin);\n    newScale = Math.min(newScale, this.config.zoomMax);\n    newScale = Math.round(newScale * 100) / 100;\n    return this.setZoom(newScale);\n  };\n\n  LiterallyCanvas.prototype.setZoom = function(scale) {\n    var oldScale;\n    oldScale = this.scale;\n    this.scale = scale;\n    this.position.x = math.scalePositionScalar(this.position.x, this.canvas.width, oldScale, this.scale);\n    this.position.y = math.scalePositionScalar(this.position.y, this.canvas.height, oldScale, this.scale);\n    this.keepPanInImageBounds();\n    this.repaintAllLayers();\n    return this.trigger('zoom', {\n      oldScale: oldScale,\n      newScale: this.scale\n    });\n  };\n\n  LiterallyCanvas.prototype.setWatermarkImage = function(newImage) {\n    this.watermarkImage = newImage;\n    util.addImageOnload(newImage, (function(_this) {\n      return function() {\n        return _this.repaintLayer('background');\n      };\n    })(this));\n    if (newImage.width) {\n      return this.repaintLayer('background');\n    }\n  };\n\n  LiterallyCanvas.prototype.repaintAllLayers = function() {\n    var i, key, len, ref1;\n    ref1 = ['background', 'main'];\n    for (i = 0, len = ref1.length; i < len; i++) {\n      key = ref1[i];\n      this.repaintLayer(key);\n    }\n    return null;\n  };\n\n  LiterallyCanvas.prototype.repaintLayer = function(repaintLayerKey, dirty) {\n    var retryCallback;\n    if (dirty == null) {\n      dirty = repaintLayerKey === 'main';\n    }\n    if (!this.isBound) {\n      return;\n    }\n    switch (repaintLayerKey) {\n      case 'background':\n        this.backgroundCtx.clearRect(0, 0, this.backgroundCanvas.width, this.backgroundCanvas.height);\n        retryCallback = (function(_this) {\n          return function() {\n            return _this.repaintLayer('background');\n          };\n        })(this);\n        if (this.watermarkImage) {\n          this._renderWatermark(this.backgroundCtx, true, retryCallback);\n        }\n        this.draw(this.backgroundShapes, this.backgroundCtx, retryCallback);\n        break;\n      case 'main':\n        retryCallback = (function(_this) {\n          return function() {\n            return _this.repaintLayer('main', true);\n          };\n        })(this);\n        if (dirty) {\n          this.buffer.width = this.canvas.width;\n          this.buffer.height = this.canvas.height;\n          this.bufferCtx.clearRect(0, 0, this.buffer.width, this.buffer.height);\n          this.draw(this.shapes, this.bufferCtx, retryCallback);\n        }\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.canvas.width > 0 && this.canvas.height > 0) {\n          this.ctx.fillStyle = '#ccc';\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          this.clipped(((function(_this) {\n            return function() {\n              _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);\n              return _this.ctx.drawImage(_this.buffer, 0, 0);\n            };\n          })(this)), this.ctx);\n          this.clipped(((function(_this) {\n            return function() {\n              return _this.transformed((function() {\n                var i, len, ref1, results, shape;\n                ref1 = _this._shapesInProgress;\n                results = [];\n                for (i = 0, len = ref1.length; i < len; i++) {\n                  shape = ref1[i];\n                  results.push(renderShapeToContext(_this.ctx, shape, {\n                    bufferCtx: _this.bufferCtx,\n                    shouldOnlyDrawLatest: true\n                  }));\n                }\n                return results;\n              }), _this.ctx, _this.bufferCtx);\n            };\n          })(this)), this.ctx, this.bufferCtx);\n        }\n    }\n    return this.trigger('repaint', {\n      layerKey: repaintLayerKey\n    });\n  };\n\n  LiterallyCanvas.prototype._renderWatermark = function(ctx, worryAboutRetina, retryCallback) {\n    if (worryAboutRetina == null) {\n      worryAboutRetina = true;\n    }\n    if (!this.watermarkImage.width) {\n      this.watermarkImage.onload = retryCallback;\n      return;\n    }\n    ctx.save();\n    ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);\n    ctx.scale(this.watermarkScale, this.watermarkScale);\n    if (worryAboutRetina) {\n      ctx.scale(this.backingScale, this.backingScale);\n    }\n    ctx.drawImage(this.watermarkImage, -this.watermarkImage.width / 2, -this.watermarkImage.height / 2);\n    return ctx.restore();\n  };\n\n  LiterallyCanvas.prototype.drawShapeInProgress = function(shape) {\n    this.repaintLayer('main', false);\n    return this.clipped(((function(_this) {\n      return function() {\n        return _this.transformed((function() {\n          return renderShapeToContext(_this.ctx, shape, {\n            bufferCtx: _this.bufferCtx,\n            shouldOnlyDrawLatest: true\n          });\n        }), _this.ctx, _this.bufferCtx);\n      };\n    })(this)), this.ctx, this.bufferCtx);\n  };\n\n  LiterallyCanvas.prototype.draw = function(shapes, ctx, retryCallback) {\n    var drawShapes;\n    if (!shapes.length) {\n      return;\n    }\n    drawShapes = (function(_this) {\n      return function() {\n        var i, len, results, shape;\n        results = [];\n        for (i = 0, len = shapes.length; i < len; i++) {\n          shape = shapes[i];\n          results.push(renderShapeToContext(ctx, shape, {\n            retryCallback: retryCallback\n          }));\n        }\n        return results;\n      };\n    })(this);\n    return this.clipped(((function(_this) {\n      return function() {\n        return _this.transformed(drawShapes, ctx);\n      };\n    })(this)), ctx);\n  };\n\n  LiterallyCanvas.prototype.clipped = function() {\n    var contexts, ctx, fn, height, i, j, len, len1, results, width, x, y;\n    fn = arguments[0], contexts = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    x = this.width === INFINITE ? 0 : this.position.x;\n    y = this.height === INFINITE ? 0 : this.position.y;\n    width = (function() {\n      switch (this.width) {\n        case INFINITE:\n          return this.canvas.width;\n        default:\n          return this.width * this.getRenderScale();\n      }\n    }).call(this);\n    height = (function() {\n      switch (this.height) {\n        case INFINITE:\n          return this.canvas.height;\n        default:\n          return this.height * this.getRenderScale();\n      }\n    }).call(this);\n    for (i = 0, len = contexts.length; i < len; i++) {\n      ctx = contexts[i];\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect(x, y, width, height);\n      ctx.clip();\n    }\n    fn();\n    results = [];\n    for (j = 0, len1 = contexts.length; j < len1; j++) {\n      ctx = contexts[j];\n      results.push(ctx.restore());\n    }\n    return results;\n  };\n\n  LiterallyCanvas.prototype.transformed = function() {\n    var contexts, ctx, fn, i, j, len, len1, results, scale;\n    fn = arguments[0], contexts = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    for (i = 0, len = contexts.length; i < len; i++) {\n      ctx = contexts[i];\n      ctx.save();\n      ctx.translate(Math.floor(this.position.x), Math.floor(this.position.y));\n      scale = this.getRenderScale();\n      ctx.scale(scale, scale);\n    }\n    fn();\n    results = [];\n    for (j = 0, len1 = contexts.length; j < len1; j++) {\n      ctx = contexts[j];\n      results.push(ctx.restore());\n    }\n    return results;\n  };\n\n  LiterallyCanvas.prototype.clear = function(triggerClearEvent) {\n    var newShapes, oldShapes;\n    if (triggerClearEvent == null) {\n      triggerClearEvent = true;\n    }\n    oldShapes = this.shapes;\n    newShapes = [];\n    this.setShapesInProgress([]);\n    this.execute(new actions.ClearAction(this, oldShapes, newShapes));\n    this.repaintLayer('main');\n    if (triggerClearEvent) {\n      this.trigger('clear', null);\n    }\n    return this.trigger('drawingChange', {});\n  };\n\n  LiterallyCanvas.prototype.execute = function(action) {\n    this.undoStack.push(action);\n    action[\"do\"]();\n    return this.redoStack = [];\n  };\n\n  LiterallyCanvas.prototype.undo = function() {\n    var action;\n    if (!this.undoStack.length) {\n      return;\n    }\n    action = this.undoStack.pop();\n    action.undo();\n    this.redoStack.push(action);\n    this.trigger('undo', {\n      action: action\n    });\n    return this.trigger('drawingChange', {});\n  };\n\n  LiterallyCanvas.prototype.redo = function() {\n    var action;\n    if (!this.redoStack.length) {\n      return;\n    }\n    action = this.redoStack.pop();\n    this.undoStack.push(action);\n    action[\"do\"]();\n    this.trigger('redo', {\n      action: action\n    });\n    return this.trigger('drawingChange', {});\n  };\n\n  LiterallyCanvas.prototype.canUndo = function() {\n    return !!this.undoStack.length;\n  };\n\n  LiterallyCanvas.prototype.canRedo = function() {\n    return !!this.redoStack.length;\n  };\n\n  LiterallyCanvas.prototype.getPixel = function(x, y) {\n    var p, pixel;\n    p = this.drawingCoordsToClientCoords(x, y);\n    pixel = this.ctx.getImageData(p.x, p.y, 1, 1).data;\n    if (pixel[3]) {\n      return \"rgb(\" + pixel[0] + \", \" + pixel[1] + \", \" + pixel[2] + \")\";\n    } else {\n      return null;\n    }\n  };\n\n  LiterallyCanvas.prototype.getContentBounds = function() {\n    return util.getBoundingRect((this.shapes.concat(this.backgroundShapes)).map(function(s) {\n      return s.getBoundingRect();\n    }), this.width === INFINITE ? 0 : this.width, this.height === INFINITE ? 0 : this.height);\n  };\n\n  LiterallyCanvas.prototype.getDefaultImageRect = function(explicitSize, margin) {\n    var s;\n    if (explicitSize == null) {\n      explicitSize = {\n        width: 0,\n        height: 0\n      };\n    }\n    if (margin == null) {\n      margin = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n    }\n    return util.getDefaultImageRect((function() {\n      var i, len, ref1, results;\n      ref1 = this.shapes.concat(this.backgroundShapes);\n      results = [];\n      for (i = 0, len = ref1.length; i < len; i++) {\n        s = ref1[i];\n        results.push(s.getBoundingRect(this.ctx));\n      }\n      return results;\n    }).call(this), explicitSize, margin);\n  };\n\n  LiterallyCanvas.prototype.getImage = function(opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    if (opts.includeWatermark == null) {\n      opts.includeWatermark = true;\n    }\n    if (opts.scaleDownRetina == null) {\n      opts.scaleDownRetina = true;\n    }\n    if (opts.scale == null) {\n      opts.scale = 1;\n    }\n    if (!opts.scaleDownRetina) {\n      opts.scale *= this.backingScale;\n    }\n    if (opts.includeWatermark) {\n      opts.watermarkImage = this.watermarkImage;\n      opts.watermarkScale = this.watermarkScale;\n      if (!opts.scaleDownRetina) {\n        opts.watermarkScale *= this.backingScale;\n      }\n    }\n    return renderSnapshotToImage(this.getSnapshot(), opts);\n  };\n\n  LiterallyCanvas.prototype.canvasForExport = function() {\n    this.repaintAllLayers();\n    return util.combineCanvases(this.backgroundCanvas, this.canvas);\n  };\n\n  LiterallyCanvas.prototype.canvasWithBackground = function(backgroundImageOrCanvas) {\n    return util.combineCanvases(backgroundImageOrCanvas, this.canvasForExport());\n  };\n\n  LiterallyCanvas.prototype.getSnapshot = function(keys) {\n    var i, k, len, ref1, shape, snapshot;\n    if (keys == null) {\n      keys = null;\n    }\n    if (keys == null) {\n      keys = ['shapes', 'imageSize', 'colors', 'position', 'scale', 'backgroundShapes'];\n    }\n    snapshot = {};\n    ref1 = ['colors', 'position', 'scale'];\n    for (i = 0, len = ref1.length; i < len; i++) {\n      k = ref1[i];\n      if (indexOf.call(keys, k) >= 0) {\n        snapshot[k] = this[k];\n      }\n    }\n    if (indexOf.call(keys, 'shapes') >= 0) {\n      snapshot.shapes = (function() {\n        var j, len1, ref2, results;\n        ref2 = this.shapes;\n        results = [];\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          shape = ref2[j];\n          results.push(shapeToJSON(shape));\n        }\n        return results;\n      }).call(this);\n    }\n    if (indexOf.call(keys, 'backgroundShapes') >= 0) {\n      snapshot.backgroundShapes = (function() {\n        var j, len1, ref2, results;\n        ref2 = this.backgroundShapes;\n        results = [];\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          shape = ref2[j];\n          results.push(shapeToJSON(shape));\n        }\n        return results;\n      }).call(this);\n    }\n    if (indexOf.call(keys, 'imageSize') >= 0) {\n      snapshot.imageSize = {\n        width: this.width,\n        height: this.height\n      };\n    }\n    return snapshot;\n  };\n\n  LiterallyCanvas.prototype.getSnapshotJSON = function() {\n    console.warn(\"lc.getSnapshotJSON() is deprecated. use JSON.stringify(lc.getSnapshot()) instead.\");\n    return JSON.stringify(this.getSnapshot());\n  };\n\n  LiterallyCanvas.prototype.getSVGString = function(opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    return renderSnapshotToSVG(this.getSnapshot(), opts);\n  };\n\n  LiterallyCanvas.prototype.loadSnapshot = function(snapshot) {\n    var i, j, k, len, len1, ref1, ref2, s, shape, shapeRepr;\n    if (!snapshot) {\n      return;\n    }\n    if (snapshot.colors) {\n      ref1 = ['primary', 'secondary', 'background'];\n      for (i = 0, len = ref1.length; i < len; i++) {\n        k = ref1[i];\n        this.setColor(k, snapshot.colors[k]);\n      }\n    }\n    if (snapshot.shapes) {\n      this.shapes = [];\n      ref2 = snapshot.shapes;\n      for (j = 0, len1 = ref2.length; j < len1; j++) {\n        shapeRepr = ref2[j];\n        shape = JSONToShape(shapeRepr);\n        if (shape) {\n          this.execute(new actions.AddShapeAction(this, shape));\n        }\n      }\n    }\n    if (snapshot.backgroundShapes) {\n      this.backgroundShapes = (function() {\n        var l, len2, ref3, results;\n        ref3 = snapshot.backgroundShapes;\n        results = [];\n        for (l = 0, len2 = ref3.length; l < len2; l++) {\n          s = ref3[l];\n          results.push(JSONToShape(s));\n        }\n        return results;\n      })();\n    }\n    if (snapshot.imageSize) {\n      this.width = snapshot.imageSize.width;\n      this.height = snapshot.imageSize.height;\n    }\n    if (snapshot.position) {\n      this.position = snapshot.position;\n    }\n    if (snapshot.scale) {\n      this.scale = snapshot.scale;\n    }\n    this.repaintAllLayers();\n    this.trigger('snapshotLoad');\n    return this.trigger('drawingChange', {});\n  };\n\n  LiterallyCanvas.prototype.loadSnapshotJSON = function(str) {\n    console.warn(\"lc.loadSnapshotJSON() is deprecated. use lc.loadSnapshot(JSON.parse(snapshot)) instead.\");\n    return this.loadSnapshot(JSON.parse(str));\n  };\n\n  return LiterallyCanvas;\n\n})();\n\n\n},{\"../tools/Pencil\":48,\"./actions\":7,\"./bindEvents\":8,\"./canvasRenderer\":9,\"./math\":14,\"./renderSnapshotToImage\":15,\"./renderSnapshotToSVG\":16,\"./shapes\":17,\"./svgRenderer\":18,\"./util\":19}],6:[function(require,module,exports){\nvar TextRenderer, getLinesToRender, getNextLine, parseFontString;\n\nrequire('./fontmetrics.js');\n\nparseFontString = function(font) {\n  var fontFamily, fontItems, fontSize, item, j, len, maybeSize, remainingFontString;\n  fontItems = font.split(' ');\n  fontSize = 0;\n  for (j = 0, len = fontItems.length; j < len; j++) {\n    item = fontItems[j];\n    maybeSize = parseInt(item.replace(\"px\", \"\"), 10);\n    if (!isNaN(maybeSize)) {\n      fontSize = maybeSize;\n    }\n  }\n  if (!fontSize) {\n    throw \"Font size not found\";\n  }\n  remainingFontString = font.substring(fontItems[0].length + 1).replace('bold ', '').replace('italic ', '').replace('underline ', '');\n  fontFamily = remainingFontString;\n  return {\n    fontSize: fontSize,\n    fontFamily: fontFamily\n  };\n};\n\ngetNextLine = function(ctx, text, forcedWidth) {\n  var doesSubstringFit, endIndex, isEndOfString, isNonWord, isWhitespace, lastGoodIndex, lastOkayIndex, nextWordStartIndex, textToHere, wasInWord;\n  if (!text.length) {\n    return ['', ''];\n  }\n  endIndex = 0;\n  lastGoodIndex = 0;\n  lastOkayIndex = 0;\n  wasInWord = false;\n  while (true) {\n    endIndex += 1;\n    isEndOfString = endIndex >= text.length;\n    isWhitespace = (!isEndOfString) && text[endIndex].match(/\\s/);\n    isNonWord = isWhitespace || isEndOfString;\n    textToHere = text.substring(0, endIndex);\n    doesSubstringFit = forcedWidth ? ctx.measureTextWidth(textToHere).width <= forcedWidth : true;\n    if (doesSubstringFit) {\n      lastOkayIndex = endIndex;\n    }\n    if (isNonWord && wasInWord) {\n      wasInWord = false;\n      if (doesSubstringFit) {\n        lastGoodIndex = endIndex;\n      }\n    }\n    wasInWord = !isWhitespace;\n    if (isEndOfString || !doesSubstringFit) {\n      if (doesSubstringFit) {\n        return [text, ''];\n      } else if (lastGoodIndex > 0) {\n        nextWordStartIndex = lastGoodIndex + 1;\n        while (nextWordStartIndex < text.length && text[nextWordStartIndex].match('/\\s/')) {\n          nextWordStartIndex += 1;\n        }\n        return [text.substring(0, lastGoodIndex), text.substring(nextWordStartIndex)];\n      } else {\n        return [text.substring(0, lastOkayIndex), text.substring(lastOkayIndex)];\n      }\n    }\n  }\n};\n\ngetLinesToRender = function(ctx, text, forcedWidth) {\n  var j, len, lines, nextLine, ref, ref1, remainingText, textLine, textSplitOnLines;\n  textSplitOnLines = text.split(/\\r\\n|\\r|\\n/g);\n  lines = [];\n  for (j = 0, len = textSplitOnLines.length; j < len; j++) {\n    textLine = textSplitOnLines[j];\n    ref = getNextLine(ctx, textLine, forcedWidth), nextLine = ref[0], remainingText = ref[1];\n    if (nextLine) {\n      while (nextLine) {\n        lines.push(nextLine);\n        ref1 = getNextLine(ctx, remainingText, forcedWidth), nextLine = ref1[0], remainingText = ref1[1];\n      }\n    } else {\n      lines.push(textLine);\n    }\n  }\n  return lines;\n};\n\nTextRenderer = (function() {\n  function TextRenderer(ctx, text1, font1, forcedWidth1, forcedHeight) {\n    var fontFamily, fontSize, ref;\n    this.text = text1;\n    this.font = font1;\n    this.forcedWidth = forcedWidth1;\n    this.forcedHeight = forcedHeight;\n    ref = parseFontString(this.font), fontFamily = ref.fontFamily, fontSize = ref.fontSize;\n    ctx.font = this.font;\n    ctx.textBaseline = 'baseline';\n    this.emDashWidth = ctx.measureTextWidth('—', fontSize, fontFamily).width;\n    this.caratWidth = ctx.measureTextWidth('|', fontSize, fontFamily).width;\n    this.lines = getLinesToRender(ctx, this.text, this.forcedWidth);\n    this.metricses = this.lines.map((function(_this) {\n      return function(line) {\n        return ctx.measureText2(line || 'X', fontSize, _this.font);\n      };\n    })(this));\n    this.metrics = {\n      ascent: Math.max.apply(Math, this.metricses.map(function(arg) {\n        var ascent;\n        ascent = arg.ascent;\n        return ascent;\n      })),\n      descent: Math.max.apply(Math, this.metricses.map(function(arg) {\n        var descent;\n        descent = arg.descent;\n        return descent;\n      })),\n      fontsize: Math.max.apply(Math, this.metricses.map(function(arg) {\n        var fontsize;\n        fontsize = arg.fontsize;\n        return fontsize;\n      })),\n      leading: Math.max.apply(Math, this.metricses.map(function(arg) {\n        var leading;\n        leading = arg.leading;\n        return leading;\n      })),\n      width: Math.max.apply(Math, this.metricses.map(function(arg) {\n        var width;\n        width = arg.width;\n        return width;\n      })),\n      height: Math.max.apply(Math, this.metricses.map(function(arg) {\n        var height;\n        height = arg.height;\n        return height;\n      })),\n      bounds: {\n        minx: Math.min.apply(Math, this.metricses.map(function(arg) {\n          var bounds;\n          bounds = arg.bounds;\n          return bounds.minx;\n        })),\n        miny: Math.min.apply(Math, this.metricses.map(function(arg) {\n          var bounds;\n          bounds = arg.bounds;\n          return bounds.miny;\n        })),\n        maxx: Math.max.apply(Math, this.metricses.map(function(arg) {\n          var bounds;\n          bounds = arg.bounds;\n          return bounds.maxx;\n        })),\n        maxy: Math.max.apply(Math, this.metricses.map(function(arg) {\n          var bounds;\n          bounds = arg.bounds;\n          return bounds.maxy;\n        }))\n      }\n    };\n    this.boundingBoxWidth = Math.ceil(this.metrics.width);\n  }\n\n  TextRenderer.prototype.draw = function(ctx, x, y) {\n    var i, j, len, line, ref, results;\n    ctx.textBaseline = 'top';\n    ctx.font = this.font;\n    i = 0;\n    ref = this.lines;\n    results = [];\n    for (j = 0, len = ref.length; j < len; j++) {\n      line = ref[j];\n      ctx.fillText(line, x, y + i * this.metrics.leading);\n      results.push(i += 1);\n    }\n    return results;\n  };\n\n  TextRenderer.prototype.getWidth = function(isEditing) {\n    if (isEditing == null) {\n      isEditing = false;\n    }\n    if (this.forcedWidth) {\n      return this.forcedWidth;\n    } else {\n      if (isEditing) {\n        return this.metrics.bounds.maxx + this.caratWidth;\n      } else {\n        return this.metrics.bounds.maxx;\n      }\n    }\n  };\n\n  TextRenderer.prototype.getHeight = function() {\n    return this.forcedHeight || (this.metrics.leading * this.lines.length);\n  };\n\n  return TextRenderer;\n\n})();\n\nmodule.exports = TextRenderer;\n\n\n},{\"./fontmetrics.js\":11}],7:[function(require,module,exports){\nvar AddShapeAction, ClearAction;\n\nClearAction = (function() {\n  function ClearAction(lc1, oldShapes, newShapes1) {\n    this.lc = lc1;\n    this.oldShapes = oldShapes;\n    this.newShapes = newShapes1;\n  }\n\n  ClearAction.prototype[\"do\"] = function() {\n    this.lc.shapes = this.newShapes;\n    return this.lc.repaintLayer('main');\n  };\n\n  ClearAction.prototype.undo = function() {\n    this.lc.shapes = this.oldShapes;\n    return this.lc.repaintLayer('main');\n  };\n\n  return ClearAction;\n\n})();\n\nAddShapeAction = (function() {\n  function AddShapeAction(lc1, shape1, previousShapeId) {\n    this.lc = lc1;\n    this.shape = shape1;\n    this.previousShapeId = previousShapeId != null ? previousShapeId : null;\n  }\n\n  AddShapeAction.prototype[\"do\"] = function() {\n    var found, i, len, newShapes, ref, shape;\n    if (!this.lc.shapes.length || this.lc.shapes[this.lc.shapes.length - 1].id === this.previousShapeId || this.previousShapeId === null) {\n      this.lc.shapes.push(this.shape);\n    } else {\n      newShapes = [];\n      found = false;\n      ref = this.lc.shapes;\n      for (i = 0, len = ref.length; i < len; i++) {\n        shape = ref[i];\n        newShapes.push(shape);\n        if (shape.id === this.previousShapeId) {\n          newShapes.push(this.shape);\n          found = true;\n        }\n      }\n      if (!found) {\n        newShapes.push(this.shape);\n      }\n      this.lc.shapes = newShapes;\n    }\n    return this.lc.repaintLayer('main');\n  };\n\n  AddShapeAction.prototype.undo = function() {\n    var i, len, newShapes, ref, shape;\n    if (this.lc.shapes[this.lc.shapes.length - 1].id === this.shape.id) {\n      this.lc.shapes.pop();\n    } else {\n      newShapes = [];\n      ref = this.lc.shapes;\n      for (i = 0, len = ref.length; i < len; i++) {\n        shape = ref[i];\n        if (shape.id !== this.shape.id) {\n          newShapes.push(shape);\n        }\n      }\n      lc.shapes = newShapes;\n    }\n    return this.lc.repaintLayer('main');\n  };\n\n  return AddShapeAction;\n\n})();\n\nmodule.exports = {\n  ClearAction: ClearAction,\n  AddShapeAction: AddShapeAction\n};\n\n\n},{}],8:[function(require,module,exports){\nvar bindEvents, buttonIsDown, coordsForTouchEvent, position;\n\ncoordsForTouchEvent = function(el, e) {\n  var p, tx, ty;\n  tx = e.changedTouches[0].clientX;\n  ty = e.changedTouches[0].clientY;\n  p = el.getBoundingClientRect();\n  return [tx - p.left, ty - p.top];\n};\n\nposition = function(el, e) {\n  var p;\n  p = el.getBoundingClientRect();\n  return {\n    left: e.clientX - p.left,\n    top: e.clientY - p.top\n  };\n};\n\nbuttonIsDown = function(e) {\n  if (e.buttons != null) {\n    return e.buttons === 1;\n  } else {\n    return e.which > 0;\n  }\n};\n\nmodule.exports = bindEvents = function(lc, canvas, panWithKeyboard) {\n  var listener, mouseMoveListener, mouseUpListener, touchEndListener, touchMoveListener, unsubs;\n  if (panWithKeyboard == null) {\n    panWithKeyboard = false;\n  }\n  unsubs = [];\n  mouseMoveListener = (function(_this) {\n    return function(e) {\n      var p;\n      e.preventDefault();\n      p = position(canvas, e);\n      return lc.pointerMove(p.left, p.top);\n    };\n  })(this);\n  mouseUpListener = (function(_this) {\n    return function(e) {\n      var p;\n      e.preventDefault();\n      canvas.onselectstart = function() {\n        return true;\n      };\n      p = position(canvas, e);\n      lc.pointerUp(p.left, p.top);\n      document.removeEventListener('mousemove', mouseMoveListener);\n      document.removeEventListener('mouseup', mouseUpListener);\n      return canvas.addEventListener('mousemove', mouseMoveListener);\n    };\n  })(this);\n  canvas.addEventListener('mousedown', (function(_this) {\n    return function(e) {\n      var down, p;\n      if (e.target.tagName.toLowerCase() !== 'canvas') {\n        return;\n      }\n      down = true;\n      e.preventDefault();\n      canvas.onselectstart = function() {\n        return false;\n      };\n      p = position(canvas, e);\n      lc.pointerDown(p.left, p.top);\n      canvas.removeEventListener('mousemove', mouseMoveListener);\n      document.addEventListener('mousemove', mouseMoveListener);\n      return document.addEventListener('mouseup', mouseUpListener);\n    };\n  })(this));\n  touchMoveListener = function(e) {\n    e.preventDefault();\n    return lc.pointerMove.apply(lc, coordsForTouchEvent(canvas, e));\n  };\n  touchEndListener = function(e) {\n    e.preventDefault();\n    lc.pointerUp.apply(lc, coordsForTouchEvent(canvas, e));\n    document.removeEventListener('touchmove', touchMoveListener);\n    document.removeEventListener('touchend', touchEndListener);\n    return document.removeEventListener('touchcancel', touchEndListener);\n  };\n  canvas.addEventListener('touchstart', function(e) {\n    if (e.target.tagName.toLowerCase() !== 'canvas') {\n      return;\n    }\n    e.preventDefault();\n    if (e.touches.length === 1) {\n      lc.pointerDown.apply(lc, coordsForTouchEvent(canvas, e));\n      document.addEventListener('touchmove', touchMoveListener);\n      document.addEventListener('touchend', touchEndListener);\n      return document.addEventListener('touchcancel', touchEndListener);\n    } else {\n      return lc.pointerMove.apply(lc, coordsForTouchEvent(canvas, e));\n    }\n  });\n  if (panWithKeyboard) {\n    console.warn(\"Keyboard panning is deprecated.\");\n    listener = function(e) {\n      switch (e.keyCode) {\n        case 37:\n          lc.pan(-10, 0);\n          break;\n        case 38:\n          lc.pan(0, -10);\n          break;\n        case 39:\n          lc.pan(10, 0);\n          break;\n        case 40:\n          lc.pan(0, 10);\n      }\n      return lc.repaintAllLayers();\n    };\n    document.addEventListener('keydown', listener);\n    unsubs.push(function() {\n      return document.removeEventListener(listener);\n    });\n  }\n  return function() {\n    var f, i, len, results;\n    results = [];\n    for (i = 0, len = unsubs.length; i < len; i++) {\n      f = unsubs[i];\n      results.push(f());\n    }\n    return results;\n  };\n};\n\n\n},{}],9:[function(require,module,exports){\nvar _drawRawLinePath, defineCanvasRenderer, drawErasedLinePath, drawErasedLinePathLatest, drawLinePath, drawLinePathLatest, lineEndCapShapes, noop, renderShapeToCanvas, renderShapeToContext, renderers;\n\nlineEndCapShapes = require('./lineEndCapShapes');\n\nrenderers = {};\n\ndefineCanvasRenderer = function(shapeName, drawFunc, drawLatestFunc) {\n  return renderers[shapeName] = {\n    drawFunc: drawFunc,\n    drawLatestFunc: drawLatestFunc\n  };\n};\n\nnoop = function() {};\n\nrenderShapeToContext = function(ctx, shape, opts) {\n  var bufferCtx;\n  if (opts == null) {\n    opts = {};\n  }\n  if (opts.shouldIgnoreUnsupportedShapes == null) {\n    opts.shouldIgnoreUnsupportedShapes = false;\n  }\n  if (opts.retryCallback == null) {\n    opts.retryCallback = noop;\n  }\n  if (opts.shouldOnlyDrawLatest == null) {\n    opts.shouldOnlyDrawLatest = false;\n  }\n  if (opts.bufferCtx == null) {\n    opts.bufferCtx = null;\n  }\n  bufferCtx = opts.bufferCtx;\n  if (renderers[shape.className]) {\n    if (opts.shouldOnlyDrawLatest && renderers[shape.className].drawLatestFunc) {\n      return renderers[shape.className].drawLatestFunc(ctx, bufferCtx, shape, opts.retryCallback);\n    } else {\n      return renderers[shape.className].drawFunc(ctx, shape, opts.retryCallback);\n    }\n  } else if (opts.shouldIgnoreUnsupportedShapes) {\n    return console.warn(\"Can't render shape of type \" + shape.className + \" to canvas\");\n  } else {\n    throw \"Can't render shape of type \" + shape.className + \" to canvas\";\n  }\n};\n\nrenderShapeToCanvas = function(canvas, shape, opts) {\n  return renderShapeToContext(canvas.getContext('2d'), shape, opts);\n};\n\ndefineCanvasRenderer('Rectangle', function(ctx, shape) {\n  var x, y;\n  x = shape.x;\n  y = shape.y;\n  if (shape.strokeWidth % 2 !== 0) {\n    x += 0.5;\n    y += 0.5;\n  }\n  ctx.fillStyle = shape.fillColor;\n  ctx.fillRect(x, y, shape.width, shape.height);\n  ctx.lineWidth = shape.strokeWidth;\n  ctx.strokeStyle = shape.strokeColor;\n  return ctx.strokeRect(x, y, shape.width, shape.height);\n});\n\ndefineCanvasRenderer('Ellipse', function(ctx, shape) {\n  var centerX, centerY, halfHeight, halfWidth;\n  ctx.save();\n  halfWidth = Math.floor(shape.width / 2);\n  halfHeight = Math.floor(shape.height / 2);\n  centerX = shape.x + halfWidth;\n  centerY = shape.y + halfHeight;\n  ctx.translate(centerX, centerY);\n  ctx.scale(1, Math.abs(shape.height / shape.width));\n  ctx.beginPath();\n  ctx.arc(0, 0, Math.abs(halfWidth), 0, Math.PI * 2);\n  ctx.closePath();\n  ctx.restore();\n  ctx.fillStyle = shape.fillColor;\n  ctx.fill();\n  ctx.lineWidth = shape.strokeWidth;\n  ctx.strokeStyle = shape.strokeColor;\n  return ctx.stroke();\n});\n\ndefineCanvasRenderer('SelectionBox', (function() {\n  var _drawHandle;\n  _drawHandle = function(ctx, arg, handleSize) {\n    var x, y;\n    x = arg.x, y = arg.y;\n    if (handleSize === 0) {\n      return;\n    }\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(x, y, handleSize, handleSize);\n    ctx.strokeStyle = '#000';\n    return ctx.strokeRect(x, y, handleSize, handleSize);\n  };\n  return function(ctx, shape) {\n    _drawHandle(ctx, shape.getTopLeftHandleRect(), shape.handleSize);\n    _drawHandle(ctx, shape.getTopRightHandleRect(), shape.handleSize);\n    _drawHandle(ctx, shape.getBottomLeftHandleRect(), shape.handleSize);\n    _drawHandle(ctx, shape.getBottomRightHandleRect(), shape.handleSize);\n    if (shape.backgroundColor) {\n      ctx.fillStyle = shape.backgroundColor;\n      ctx.fillRect(shape._br.x - shape.margin, shape._br.y - shape.margin, shape._br.width + shape.margin * 2, shape._br.height + shape.margin * 2);\n    }\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = '#000';\n    ctx.setLineDash([2, 4]);\n    ctx.strokeRect(shape._br.x - shape.margin, shape._br.y - shape.margin, shape._br.width + shape.margin * 2, shape._br.height + shape.margin * 2);\n    return ctx.setLineDash([]);\n  };\n})());\n\ndefineCanvasRenderer('Image', function(ctx, shape, retryCallback) {\n  if (shape.image.width) {\n    if (shape.scale === 1) {\n      return ctx.drawImage(shape.image, shape.x, shape.y);\n    } else {\n      return ctx.drawImage(shape.image, shape.x, shape.y, shape.image.width * shape.scale, shape.image.height * shape.scale);\n    }\n  } else if (retryCallback) {\n    return shape.image.onload = retryCallback;\n  }\n});\n\ndefineCanvasRenderer('Line', function(ctx, shape) {\n  var arrowWidth, x1, x2, y1, y2;\n  if (shape.x1 === shape.x2 && shape.y1 === shape.y2) {\n    return;\n  }\n  x1 = shape.x1;\n  x2 = shape.x2;\n  y1 = shape.y1;\n  y2 = shape.y2;\n  if (shape.strokeWidth % 2 !== 0) {\n    x1 += 0.5;\n    x2 += 0.5;\n    y1 += 0.5;\n    y2 += 0.5;\n  }\n  ctx.lineWidth = shape.strokeWidth;\n  ctx.strokeStyle = shape.color;\n  ctx.lineCap = shape.capStyle;\n  if (shape.dash) {\n    ctx.setLineDash(shape.dash);\n  }\n  ctx.beginPath();\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.stroke();\n  if (shape.dash) {\n    ctx.setLineDash([]);\n  }\n  arrowWidth = Math.max(shape.strokeWidth * 2.2, 5);\n  if (shape.endCapShapes[0]) {\n    lineEndCapShapes[shape.endCapShapes[0]].drawToCanvas(ctx, x1, y1, Math.atan2(y1 - y2, x1 - x2), arrowWidth, shape.color);\n  }\n  if (shape.endCapShapes[1]) {\n    return lineEndCapShapes[shape.endCapShapes[1]].drawToCanvas(ctx, x2, y2, Math.atan2(y2 - y1, x2 - x1), arrowWidth, shape.color);\n  }\n});\n\n_drawRawLinePath = function(ctx, points, close, lineCap) {\n  var i, len, point, ref;\n  if (close == null) {\n    close = false;\n  }\n  if (lineCap == null) {\n    lineCap = 'round';\n  }\n  if (!points.length) {\n    return;\n  }\n  ctx.lineCap = lineCap;\n  ctx.strokeStyle = points[0].color;\n  ctx.lineWidth = points[0].size;\n  ctx.beginPath();\n  if (points[0].size % 2 === 0) {\n    ctx.moveTo(points[0].x, points[0].y);\n  } else {\n    ctx.moveTo(points[0].x + 0.5, points[0].y + 0.5);\n  }\n  ref = points.slice(1);\n  for (i = 0, len = ref.length; i < len; i++) {\n    point = ref[i];\n    if (points[0].size % 2 === 0) {\n      ctx.lineTo(point.x, point.y);\n    } else {\n      ctx.lineTo(point.x + 0.5, point.y + 0.5);\n    }\n  }\n  if (close) {\n    return ctx.closePath();\n  }\n};\n\ndrawLinePath = function(ctx, shape) {\n  _drawRawLinePath(ctx, shape.smoothedPoints);\n  return ctx.stroke();\n};\n\ndrawLinePathLatest = function(ctx, bufferCtx, shape) {\n  var drawEnd, drawStart, segmentStart;\n  if (shape.tail) {\n    segmentStart = shape.smoothedPoints.length - shape.segmentSize * shape.tailSize;\n    drawStart = segmentStart < shape.segmentSize * 2 ? 0 : segmentStart;\n    drawEnd = segmentStart + shape.segmentSize + 1;\n    _drawRawLinePath(bufferCtx, shape.smoothedPoints.slice(drawStart, drawEnd));\n    return bufferCtx.stroke();\n  } else {\n    _drawRawLinePath(bufferCtx, shape.smoothedPoints);\n    return bufferCtx.stroke();\n  }\n};\n\ndefineCanvasRenderer('LinePath', drawLinePath, drawLinePathLatest);\n\ndrawErasedLinePath = function(ctx, shape) {\n  ctx.save();\n  ctx.globalCompositeOperation = \"destination-out\";\n  drawLinePath(ctx, shape);\n  return ctx.restore();\n};\n\ndrawErasedLinePathLatest = function(ctx, bufferCtx, shape) {\n  ctx.save();\n  ctx.globalCompositeOperation = \"destination-out\";\n  bufferCtx.save();\n  bufferCtx.globalCompositeOperation = \"destination-out\";\n  drawLinePathLatest(ctx, bufferCtx, shape);\n  ctx.restore();\n  return bufferCtx.restore();\n};\n\ndefineCanvasRenderer('ErasedLinePath', drawErasedLinePath, drawErasedLinePathLatest);\n\ndefineCanvasRenderer('Text', function(ctx, shape) {\n  if (!shape.renderer) {\n    shape._makeRenderer(ctx);\n  }\n  ctx.fillStyle = shape.color;\n  return shape.renderer.draw(ctx, shape.x, shape.y);\n});\n\ndefineCanvasRenderer('Polygon', function(ctx, shape) {\n  ctx.fillStyle = shape.fillColor;\n  _drawRawLinePath(ctx, shape.points, shape.isClosed, 'butt');\n  ctx.fill();\n  return ctx.stroke();\n});\n\nmodule.exports = {\n  defineCanvasRenderer: defineCanvasRenderer,\n  renderShapeToCanvas: renderShapeToCanvas,\n  renderShapeToContext: renderShapeToContext\n};\n\n\n},{\"./lineEndCapShapes\":12}],10:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  imageURLPrefix: 'lib/img',\n  primaryColor: 'hsla(0, 0%, 0%, 1)',\n  secondaryColor: 'hsla(0, 0%, 100%, 1)',\n  backgroundColor: 'transparent',\n  strokeWidths: [1, 2, 5, 10, 20, 30],\n  defaultStrokeWidth: 5,\n  toolbarPosition: 'top',\n  keyboardShortcuts: false,\n  imageSize: { width: 'infinite', height: 'infinite' },\n  backgroundShapes: [],\n  watermarkImage: null,\n  watermarkScale: 1,\n  zoomMin: 0.2,\n  zoomMax: 4.0,\n  zoomStep: 0.2,\n  snapshot: null,\n  onInit: function onInit() {},\n  tools: [require('../tools/Pencil'), require('../tools/Eraser'), require('../tools/Line'), require('../tools/Rectangle'), require('../tools/Ellipse'), require('../tools/Text'), require('../tools/Polygon'), require('../tools/Pan'), require('../tools/Eyedropper')]\n};\n\n},{\"../tools/Ellipse\":43,\"../tools/Eraser\":44,\"../tools/Eyedropper\":45,\"../tools/Line\":46,\"../tools/Pan\":47,\"../tools/Pencil\":48,\"../tools/Polygon\":49,\"../tools/Rectangle\":50,\"../tools/Text\":52}],11:[function(require,module,exports){\n\"use strict\";\n\n/**\n  This library rewrites the Canvas2D \"measureText\" function\n  so that it returns a more complete metrics object.\n  This library is licensed under the MIT (Expat) license,\n  the text for which is included below.\n\n** -----------------------------------------------------------------------------\n\n  CHANGELOG:\n\n    2012-01-21 - Whitespace handling added by Joe Turner\n                 (https://github.com/oampo)\n\n    2015-06-08 - Various hacks added by Steve Johnson\n\n** -----------------------------------------------------------------------------\n\n  Copyright (C) 2011 by Mike \"Pomax\" Kamermans\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n**/\n(function () {\n  var NAME = \"FontMetrics Library\";\n  var VERSION = \"1-2012.0121.1300\";\n\n  // if there is no getComputedStyle, this library won't work.\n  if (!document.defaultView.getComputedStyle) {\n    throw \"ERROR: 'document.defaultView.getComputedStyle' not found. This library only works in browsers that can report computed CSS values.\";\n  }\n\n  // store the old text metrics function on the Canvas2D prototype\n  CanvasRenderingContext2D.prototype.measureTextWidth = CanvasRenderingContext2D.prototype.measureText;\n\n  /**\n   *  shortcut function for getting computed CSS values\n   */\n  var getCSSValue = function getCSSValue(element, property) {\n    return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);\n  };\n\n  // debug function\n  var show = function show(canvas, ctx, xstart, w, h, metrics) {\n    document.body.appendChild(canvas);\n    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n\n    ctx.beginPath();\n    ctx.moveTo(xstart, 0);\n    ctx.lineTo(xstart, h);\n    ctx.closePath();\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(xstart + metrics.bounds.maxx, 0);\n    ctx.lineTo(xstart + metrics.bounds.maxx, h);\n    ctx.closePath();\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(0, h / 2 - metrics.ascent);\n    ctx.lineTo(w, h / 2 - metrics.ascent);\n    ctx.closePath();\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(0, h / 2 + metrics.descent);\n    ctx.lineTo(w, h / 2 + metrics.descent);\n    ctx.closePath();\n    ctx.stroke();\n  };\n\n  /**\n   * The new text metrics function\n   */\n  CanvasRenderingContext2D.prototype.measureText2 = function (textstring, fontSize, fontString) {\n    var metrics = this.measureTextWidth(textstring),\n        isSpace = !/\\S/.test(textstring);\n    metrics.fontsize = fontSize;\n\n    // for text lead values, we meaure a multiline text container.\n    var leadDiv = document.createElement(\"div\");\n    leadDiv.style.position = \"absolute\";\n    leadDiv.style.opacity = 0;\n    leadDiv.style.font = fontString;\n    leadDiv.innerHTML = textstring + \"<br/>\" + textstring;\n    document.body.appendChild(leadDiv);\n\n    // make some initial guess at the text leading (using the standard TeX ratio)\n    metrics.leading = 1.2 * fontSize;\n\n    // then we try to get the real value from the browser\n    var leadDivHeight = getCSSValue(leadDiv, \"height\");\n    leadDivHeight = leadDivHeight.replace(\"px\", \"\");\n    if (leadDivHeight >= fontSize * 2) {\n      metrics.leading = leadDivHeight / 2 | 0;\n    }\n    document.body.removeChild(leadDiv);\n\n    // if we're not dealing with white space, we can compute metrics\n    if (!isSpace) {\n      // Have characters, so measure the text\n      var canvas = document.createElement(\"canvas\");\n      var padding = 100;\n      canvas.width = metrics.width + padding;\n      canvas.height = 3 * fontSize;\n      canvas.style.opacity = 1;\n      canvas.style.font = fontString;\n      var ctx = canvas.getContext(\"2d\");\n      ctx.font = fontString;\n\n      var w = canvas.width,\n          h = canvas.height,\n          baseline = h / 2;\n\n      // Set all canvas pixeldata values to 255, with all the content\n      // data being 0. This lets us scan for data[i] != 255.\n      ctx.fillStyle = \"white\";\n      ctx.fillRect(-1, -1, w + 2, h + 2);\n      ctx.fillStyle = \"black\";\n      ctx.fillText(textstring, padding / 2, baseline);\n      var pixelData = ctx.getImageData(0, 0, w, h).data;\n\n      // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,\n      // consecutive values in the array, rather than stored as 32 bit ints.\n      var i = 0,\n          w4 = w * 4,\n          len = pixelData.length;\n\n      // Finding the ascent uses a normal, forward scanline\n      while (++i < len && pixelData[i] === 255) {}\n      var ascent = i / w4 | 0;\n\n      // Finding the descent uses a reverse scanline\n      i = len - 1;\n      while (--i > 0 && pixelData[i] === 255) {}\n      var descent = i / w4 | 0;\n\n      // find the min-x coordinate\n      for (i = 0; i < len && pixelData[i] === 255;) {\n        i += w4;\n        if (i >= len) {\n          i = i - len + 4;\n        }\n      }\n      var minx = i % w4 / 4 | 0;\n\n      // find the max-x coordinate\n      var step = 1;\n      for (i = len - 3; i >= 0 && pixelData[i] === 255;) {\n        i -= w4;\n        if (i < 0) {\n          i = len - 3 - step++ * 4;\n        }\n      }\n      var maxx = i % w4 / 4 + 1 | 0;\n\n      // set font metrics\n      metrics.ascent = baseline - ascent;\n      metrics.descent = descent - baseline;\n      metrics.bounds = { minx: minx - padding / 2,\n        maxx: maxx - padding / 2,\n        miny: 0,\n        maxy: descent - ascent };\n      metrics.height = 1 + (descent - ascent);\n    }\n\n    // if we ARE dealing with whitespace, most values will just be zero.\n    else {\n        // Only whitespace, so we can't measure the text\n        metrics.ascent = 0;\n        metrics.descent = 0;\n        metrics.bounds = { minx: 0,\n          maxx: metrics.width, // Best guess\n          miny: 0,\n          maxy: 0 };\n        metrics.height = 0;\n      }\n    return metrics;\n  };\n})();\n\n},{}],12:[function(require,module,exports){\nmodule.exports = {\n  arrow: (function() {\n    var getPoints;\n    getPoints = function(x, y, angle, width, length) {\n      return [\n        {\n          x: x + Math.cos(angle + Math.PI / 2) * width / 2,\n          y: y + Math.sin(angle + Math.PI / 2) * width / 2\n        }, {\n          x: x + Math.cos(angle) * length,\n          y: y + Math.sin(angle) * length\n        }, {\n          x: x + Math.cos(angle - Math.PI / 2) * width / 2,\n          y: y + Math.sin(angle - Math.PI / 2) * width / 2\n        }\n      ];\n    };\n    return {\n      drawToCanvas: function(ctx, x, y, angle, width, color, length) {\n        var points;\n        if (length == null) {\n          length = 0;\n        }\n        length = length || width;\n        ctx.fillStyle = color;\n        ctx.lineWidth = 0;\n        ctx.strokeStyle = 'transparent';\n        ctx.beginPath();\n        points = getPoints(x, y, angle, width, length);\n        ctx.moveTo(points[0].x, points[0].y);\n        ctx.lineTo(points[1].x, points[1].y);\n        ctx.lineTo(points[2].x, points[2].y);\n        return ctx.fill();\n      },\n      svg: function(x, y, angle, width, color, length) {\n        var points;\n        if (length == null) {\n          length = 0;\n        }\n        length = length || width;\n        points = getPoints(x, y, angle, width, length);\n        return \"<polygon fill='\" + color + \"' stroke='none' points='\" + (points.map(function(p) {\n          return p.x + \",\" + p.y;\n        })) + \"' />\";\n      }\n    };\n  })()\n};\n\n\n},{}],13:[function(require,module,exports){\nvar _, localize, strings;\n\nstrings = {};\n\nlocalize = function(localStrings) {\n  return strings = localStrings;\n};\n\n_ = function(string) {\n  var translation;\n  translation = strings[string];\n  return translation || string;\n};\n\nmodule.exports = {\n  localize: localize,\n  _: _\n};\n\n\n},{}],14:[function(require,module,exports){\nvar Point, _slope, math, normals, unit, util;\n\nPoint = require('./shapes').Point;\n\nutil = require('./util');\n\nmath = {};\n\nmath.toPoly = function(line) {\n  var i, index, len, n, point, polyLeft, polyRight;\n  polyLeft = [];\n  polyRight = [];\n  index = 0;\n  for (i = 0, len = line.length; i < len; i++) {\n    point = line[i];\n    n = normals(point, _slope(line, index));\n    polyLeft = polyLeft.concat([n[0]]);\n    polyRight = [n[1]].concat(polyRight);\n    index += 1;\n  }\n  return polyLeft.concat(polyRight);\n};\n\n_slope = function(line, index) {\n  var point;\n  if (line.length < 3) {\n    point = {\n      x: 0,\n      y: 0\n    };\n  }\n  if (index === 0) {\n    point = _slope(line, index + 1);\n  } else if (index === line.length - 1) {\n    point = _slope(line, index - 1);\n  } else {\n    point = math.diff(line[index - 1], line[index + 1]);\n  }\n  return point;\n};\n\nmath.diff = function(a, b) {\n  return {\n    x: b.x - a.x,\n    y: b.y - a.y\n  };\n};\n\nunit = function(vector) {\n  var length;\n  length = math.len(vector);\n  return {\n    x: vector.x / length,\n    y: vector.y / length\n  };\n};\n\nnormals = function(p, slope) {\n  slope = unit(slope);\n  slope.x = slope.x * p.size / 2;\n  slope.y = slope.y * p.size / 2;\n  return [\n    {\n      x: p.x - slope.y,\n      y: p.y + slope.x,\n      color: p.color\n    }, {\n      x: p.x + slope.y,\n      y: p.y - slope.x,\n      color: p.color\n    }\n  ];\n};\n\nmath.len = function(vector) {\n  return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n};\n\nmath.scalePositionScalar = function(val, viewportSize, oldScale, newScale) {\n  var newSize, oldSize;\n  oldSize = viewportSize * oldScale;\n  newSize = viewportSize * newScale;\n  return val + (oldSize - newSize) / 2;\n};\n\nmodule.exports = math;\n\n\n},{\"./shapes\":17,\"./util\":19}],15:[function(require,module,exports){\nvar INFINITE, JSONToShape, renderWatermark, util;\n\nutil = require('./util');\n\nJSONToShape = require('./shapes').JSONToShape;\n\nINFINITE = 'infinite';\n\nrenderWatermark = function(ctx, image, scale) {\n  if (!image.width) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);\n  ctx.scale(scale, scale);\n  ctx.drawImage(image, -image.width / 2, -image.height / 2);\n  return ctx.restore();\n};\n\nmodule.exports = function(snapshot, opts) {\n  var allShapes, backgroundShapes, colors, imageSize, s, shapes, watermarkCanvas, watermarkCtx;\n  if (opts == null) {\n    opts = {};\n  }\n  if (opts.scale == null) {\n    opts.scale = 1;\n  }\n  shapes = (function() {\n    var i, len, ref, results;\n    ref = snapshot.shapes;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      s = ref[i];\n      results.push(JSONToShape(s));\n    }\n    return results;\n  })();\n  backgroundShapes = [];\n  if (snapshot.backgroundShapes) {\n    backgroundShapes = (function() {\n      var i, len, ref, results;\n      ref = snapshot.backgroundShapes;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        s = ref[i];\n        results.push(JSONToShape(s));\n      }\n      return results;\n    })();\n  }\n  if (opts.margin == null) {\n    opts.margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  imageSize = snapshot.imageSize || {\n    width: INFINITE,\n    height: INFINITE\n  };\n  colors = snapshot.colors || {\n    background: 'transparent'\n  };\n  allShapes = shapes.concat(backgroundShapes);\n  watermarkCanvas = document.createElement('canvas');\n  watermarkCtx = watermarkCanvas.getContext('2d');\n  if (opts.rect) {\n    opts.rect.x -= opts.margin.left;\n    opts.rect.y -= opts.margin.top;\n    opts.rect.width += opts.margin.left + opts.margin.right;\n    opts.rect.height += opts.margin.top + opts.margin.bottom;\n  } else {\n    opts.rect = util.getDefaultImageRect((function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = allShapes.length; i < len; i++) {\n        s = allShapes[i];\n        results.push(s.getBoundingRect(watermarkCtx));\n      }\n      return results;\n    })(), imageSize, opts.margin);\n  }\n  watermarkCanvas.width = opts.rect.width * opts.scale;\n  watermarkCanvas.height = opts.rect.height * opts.scale;\n  watermarkCtx.fillStyle = colors.background;\n  watermarkCtx.fillRect(0, 0, watermarkCanvas.width, watermarkCanvas.height);\n  if (!(opts.rect.width && opts.rect.height)) {\n    return null;\n  }\n  if (opts.watermarkImage) {\n    renderWatermark(watermarkCtx, opts.watermarkImage, opts.watermarkScale);\n  }\n  return util.combineCanvases(watermarkCanvas, util.renderShapes(backgroundShapes, opts.rect, opts.scale), util.renderShapes(shapes, opts.rect, opts.scale));\n};\n\n\n},{\"./shapes\":17,\"./util\":19}],16:[function(require,module,exports){\nvar INFINITE, JSONToShape, util;\n\nutil = require('./util');\n\nJSONToShape = require('./shapes').JSONToShape;\n\nINFINITE = 'infinite';\n\nmodule.exports = function(snapshot, opts) {\n  var allShapes, backgroundShapes, colors, ctx, dummyCanvas, imageSize, s, shapes;\n  if (opts == null) {\n    opts = {};\n  }\n  shapes = (function() {\n    var i, len, ref, results;\n    ref = snapshot.shapes;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      s = ref[i];\n      results.push(JSONToShape(s));\n    }\n    return results;\n  })();\n  backgroundShapes = [];\n  if (snapshot.backgroundShapes) {\n    backgroundShapes = (function() {\n      var i, len, ref, results;\n      ref = snapshot.backgroundShapes;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        s = ref[i];\n        results.push(JSONToShape(s));\n      }\n      return results;\n    })();\n  }\n  if (opts.margin == null) {\n    opts.margin = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  imageSize = snapshot.imageSize || {\n    width: INFINITE,\n    height: INFINITE\n  };\n  colors = snapshot.colors || {\n    background: 'transparent'\n  };\n  allShapes = shapes.concat(backgroundShapes);\n  dummyCanvas = document.createElement('canvas');\n  ctx = dummyCanvas.getContext('2d');\n  if (opts.rect) {\n    opts.rect.x -= opts.margin.left;\n    opts.rect.y -= opts.margin.top;\n    opts.rect.width += opts.margin.left + opts.margin.right;\n    opts.rect.height += opts.margin.top + opts.margin.bottom;\n  } else {\n    opts.rect = util.getDefaultImageRect((function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = allShapes.length; i < len; i++) {\n        s = allShapes[i];\n        results.push(s.getBoundingRect(ctx));\n      }\n      return results;\n    })(), imageSize, opts.margin);\n  }\n  return LC.renderShapesToSVG(backgroundShapes.concat(shapes), opts.rect, colors.background);\n};\n\n\n},{\"./shapes\":17,\"./util\":19}],17:[function(require,module,exports){\nvar JSONToShape, LinePath, TextRenderer, _createLinePathFromData, _doAllPointsShareStyle, _dual, _mid, _refine, bspline, createShape, defineCanvasRenderer, defineSVGRenderer, defineShape, lineEndCapShapes, linePathFuncs, ref, ref1, renderShapeToContext, renderShapeToSVG, shapeToJSON, shapes, util;\n\nutil = require('./util');\n\nTextRenderer = require('./TextRenderer');\n\nlineEndCapShapes = require('./lineEndCapShapes');\n\nref = require('./canvasRenderer'), defineCanvasRenderer = ref.defineCanvasRenderer, renderShapeToContext = ref.renderShapeToContext;\n\nref1 = require('./svgRenderer'), defineSVGRenderer = ref1.defineSVGRenderer, renderShapeToSVG = ref1.renderShapeToSVG;\n\nshapes = {};\n\ndefineShape = function(name, props) {\n  var Shape, drawFunc, drawLatestFunc, k, legacyDrawFunc, legacyDrawLatestFunc, legacySVGFunc, svgFunc;\n  Shape = function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n    props.constructor.call(this, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n    return this;\n  };\n  Shape.prototype.className = name;\n  Shape.fromJSON = props.fromJSON;\n  if (props.draw) {\n    legacyDrawFunc = props.draw;\n    legacyDrawLatestFunc = props.draw || function(ctx, bufferCtx, retryCallback) {\n      return this.draw(ctx, bufferCtx, retryCallback);\n    };\n    drawFunc = function(ctx, shape, retryCallback) {\n      return legacyDrawFunc.call(shape, ctx, retryCallback);\n    };\n    drawLatestFunc = function(ctx, bufferCtx, shape, retryCallback) {\n      return legacyDrawLatestFunc.call(shape, ctx, bufferCtx, retryCallback);\n    };\n    delete props.draw;\n    if (props.drawLatest) {\n      delete props.drawLatest;\n    }\n    defineCanvasRenderer(name, drawFunc, drawLatestFunc);\n  }\n  if (props.toSVG) {\n    legacySVGFunc = props.toSVG;\n    svgFunc = function(shape) {\n      return legacySVGFunc.call(shape);\n    };\n    delete props.toSVG;\n    defineSVGRenderer(name, svgFunc);\n  }\n  Shape.prototype.draw = function(ctx, retryCallback) {\n    return renderShapeToContext(ctx, this, {\n      retryCallback: retryCallback\n    });\n  };\n  Shape.prototype.drawLatest = function(ctx, bufferCtx, retryCallback) {\n    return renderShapeToContext(ctx, this, {\n      retryCallback: retryCallback,\n      bufferCtx: bufferCtx,\n      shouldOnlyDrawLatest: true\n    });\n  };\n  Shape.prototype.toSVG = function() {\n    return renderShapeToSVG(this);\n  };\n  for (k in props) {\n    if (k !== 'fromJSON') {\n      Shape.prototype[k] = props[k];\n    }\n  }\n  shapes[name] = Shape;\n  return Shape;\n};\n\ncreateShape = function(name, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n  var s;\n  s = new shapes[name](a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n  s.id = util.getGUID();\n  return s;\n};\n\nJSONToShape = function(arg) {\n  var className, data, id, shape;\n  className = arg.className, data = arg.data, id = arg.id;\n  if (className in shapes) {\n    shape = shapes[className].fromJSON(data);\n    if (shape) {\n      if (id) {\n        shape.id = id;\n      }\n      return shape;\n    } else {\n      console.log('Unreadable shape:', className, data);\n      return null;\n    }\n  } else {\n    console.log(\"Unknown shape:\", className, data);\n    return null;\n  }\n};\n\nshapeToJSON = function(shape) {\n  return {\n    className: shape.className,\n    data: shape.toJSON(),\n    id: shape.id\n  };\n};\n\nbspline = function(points, order) {\n  if (!order) {\n    return points;\n  }\n  return bspline(_dual(_dual(_refine(points))), order - 1);\n};\n\n_refine = function(points) {\n  var index, len, point, q, refined;\n  points = [points[0]].concat(points).concat(util.last(points));\n  refined = [];\n  index = 0;\n  for (q = 0, len = points.length; q < len; q++) {\n    point = points[q];\n    refined[index * 2] = point;\n    if (points[index + 1]) {\n      refined[index * 2 + 1] = _mid(point, points[index + 1]);\n    }\n    index += 1;\n  }\n  return refined;\n};\n\n_dual = function(points) {\n  var dualed, index, len, point, q;\n  dualed = [];\n  index = 0;\n  for (q = 0, len = points.length; q < len; q++) {\n    point = points[q];\n    if (points[index + 1]) {\n      dualed[index] = _mid(point, points[index + 1]);\n    }\n    index += 1;\n  }\n  return dualed;\n};\n\n_mid = function(a, b) {\n  return createShape('Point', {\n    x: a.x + ((b.x - a.x) / 2),\n    y: a.y + ((b.y - a.y) / 2),\n    size: a.size + ((b.size - a.size) / 2),\n    color: a.color\n  });\n};\n\ndefineShape('Image', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.x = args.x || 0;\n    this.y = args.y || 0;\n    this.scale = args.scale || 1;\n    return this.image = args.image || null;\n  },\n  getBoundingRect: function() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.image.width * this.scale,\n      height: this.image.height * this.scale\n    };\n  },\n  toJSON: function() {\n    return {\n      x: this.x,\n      y: this.y,\n      imageSrc: this.image.src,\n      imageObject: this.image,\n      scale: this.scale\n    };\n  },\n  fromJSON: function(data) {\n    var img, ref2;\n    img = null;\n    if ((ref2 = data.imageObject) != null ? ref2.width : void 0) {\n      img = data.imageObject;\n    } else {\n      img = new Image();\n      img.src = data.imageSrc;\n    }\n    return createShape('Image', {\n      x: data.x,\n      y: data.y,\n      image: img,\n      scale: data.scale\n    });\n  },\n  move: function(moveInfo) {\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    this.x = this.x - moveInfo.xDiff;\n    return this.y = this.y - moveInfo.yDiff;\n  },\n  setUpperLeft: function(upperLeft) {\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    this.x = upperLeft.x;\n    return this.y = upperLeft.y;\n  }\n});\n\ndefineShape('Rectangle', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.x = args.x || 0;\n    this.y = args.y || 0;\n    this.width = args.width || 0;\n    this.height = args.height || 0;\n    this.strokeWidth = args.strokeWidth || 1;\n    this.strokeColor = args.strokeColor || 'black';\n    return this.fillColor = args.fillColor || 'transparent';\n  },\n  getBoundingRect: function() {\n    return {\n      x: this.x - this.strokeWidth / 2,\n      y: this.y - this.strokeWidth / 2,\n      width: this.width + this.strokeWidth,\n      height: this.height + this.strokeWidth\n    };\n  },\n  toJSON: function() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      strokeWidth: this.strokeWidth,\n      strokeColor: this.strokeColor,\n      fillColor: this.fillColor\n    };\n  },\n  fromJSON: function(data) {\n    return createShape('Rectangle', data);\n  },\n  move: function(moveInfo) {\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    this.x = this.x - moveInfo.xDiff;\n    return this.y = this.y - moveInfo.yDiff;\n  },\n  setUpperLeft: function(upperLeft) {\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    this.x = upperLeft.x;\n    return this.y = upperLeft.y;\n  }\n});\n\ndefineShape('Ellipse', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.x = args.x || 0;\n    this.y = args.y || 0;\n    this.width = args.width || 0;\n    this.height = args.height || 0;\n    this.strokeWidth = args.strokeWidth || 1;\n    this.strokeColor = args.strokeColor || 'black';\n    return this.fillColor = args.fillColor || 'transparent';\n  },\n  getBoundingRect: function() {\n    return {\n      x: this.x - this.strokeWidth / 2,\n      y: this.y - this.strokeWidth / 2,\n      width: this.width + this.strokeWidth,\n      height: this.height + this.strokeWidth\n    };\n  },\n  toJSON: function() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      strokeWidth: this.strokeWidth,\n      strokeColor: this.strokeColor,\n      fillColor: this.fillColor\n    };\n  },\n  fromJSON: function(data) {\n    return createShape('Ellipse', data);\n  },\n  move: function(moveInfo) {\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    this.x = this.x - moveInfo.xDiff;\n    return this.y = this.y - moveInfo.yDiff;\n  },\n  setUpperLeft: function(upperLeft) {\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    this.x = upperLeft.x;\n    return this.y = upperLeft.y;\n  }\n});\n\ndefineShape('Line', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.x1 = args.x1 || 0;\n    this.y1 = args.y1 || 0;\n    this.x2 = args.x2 || 0;\n    this.y2 = args.y2 || 0;\n    this.strokeWidth = args.strokeWidth || 1;\n    this.color = args.color || 'black';\n    this.capStyle = args.capStyle || 'round';\n    this.endCapShapes = args.endCapShapes || [null, null];\n    return this.dash = args.dash || null;\n  },\n  getBoundingRect: function() {\n    return {\n      x: Math.min(this.x1, this.x2) - this.strokeWidth / 2,\n      y: Math.min(this.y1, this.y2) - this.strokeWidth / 2,\n      width: Math.abs(this.x2 - this.x1) + this.strokeWidth / 2,\n      height: Math.abs(this.y2 - this.y1) + this.strokeWidth / 2\n    };\n  },\n  toJSON: function() {\n    return {\n      x1: this.x1,\n      y1: this.y1,\n      x2: this.x2,\n      y2: this.y2,\n      strokeWidth: this.strokeWidth,\n      color: this.color,\n      capStyle: this.capStyle,\n      dash: this.dash,\n      endCapShapes: this.endCapShapes\n    };\n  },\n  fromJSON: function(data) {\n    return createShape('Line', data);\n  },\n  move: function(moveInfo) {\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    this.x1 = this.x1 - moveInfo.xDiff;\n    this.y1 = this.y1 - moveInfo.yDiff;\n    this.x2 = this.x2 - moveInfo.xDiff;\n    return this.y2 = this.y2 - moveInfo.yDiff;\n  },\n  setUpperLeft: function(upperLeft) {\n    var br, xDiff, yDiff;\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    br = this.getBoundingRect();\n    xDiff = br.x - upperLeft.x;\n    yDiff = br.y - upperLeft.y;\n    return this.move({\n      xDiff: xDiff,\n      yDiff: yDiff\n    });\n  }\n});\n\n_doAllPointsShareStyle = function(points) {\n  var color, len, point, q, size;\n  if (!points.length) {\n    return false;\n  }\n  size = points[0].size;\n  color = points[0].color;\n  for (q = 0, len = points.length; q < len; q++) {\n    point = points[q];\n    if (!(point.size === size && point.color === color)) {\n      console.log(size, color, point.size, point.color);\n    }\n    if (!(point.size === size && point.color === color)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n_createLinePathFromData = function(shapeName, data) {\n  var pointData, points, smoothedPoints, x, y;\n  points = null;\n  if (data.points) {\n    points = (function() {\n      var len, q, ref2, results;\n      ref2 = data.points;\n      results = [];\n      for (q = 0, len = ref2.length; q < len; q++) {\n        pointData = ref2[q];\n        results.push(JSONToShape(pointData));\n      }\n      return results;\n    })();\n  } else if (data.pointCoordinatePairs) {\n    points = (function() {\n      var len, q, ref2, ref3, results;\n      ref2 = data.pointCoordinatePairs;\n      results = [];\n      for (q = 0, len = ref2.length; q < len; q++) {\n        ref3 = ref2[q], x = ref3[0], y = ref3[1];\n        results.push(JSONToShape({\n          className: 'Point',\n          data: {\n            x: x,\n            y: y,\n            size: data.pointSize,\n            color: data.pointColor,\n            smooth: data.smooth\n          }\n        }));\n      }\n      return results;\n    })();\n  }\n  smoothedPoints = null;\n  if (data.smoothedPointCoordinatePairs) {\n    smoothedPoints = (function() {\n      var len, q, ref2, ref3, results;\n      ref2 = data.smoothedPointCoordinatePairs;\n      results = [];\n      for (q = 0, len = ref2.length; q < len; q++) {\n        ref3 = ref2[q], x = ref3[0], y = ref3[1];\n        results.push(JSONToShape({\n          className: 'Point',\n          data: {\n            x: x,\n            y: y,\n            size: data.pointSize,\n            color: data.pointColor,\n            smooth: data.smooth\n          }\n        }));\n      }\n      return results;\n    })();\n  }\n  if (!points[0]) {\n    return null;\n  }\n  return createShape(shapeName, {\n    points: points,\n    smoothedPoints: smoothedPoints,\n    order: data.order,\n    tailSize: data.tailSize,\n    smooth: data.smooth\n  });\n};\n\nlinePathFuncs = {\n  constructor: function(args) {\n    var len, point, points, q, results;\n    if (args == null) {\n      args = {};\n    }\n    points = args.points || [];\n    this.order = args.order || 3;\n    this.tailSize = args.tailSize || 3;\n    this.smooth = 'smooth' in args ? args.smooth : true;\n    this.segmentSize = Math.pow(2, this.order);\n    this.sampleSize = this.tailSize + 1;\n    if (args.smoothedPoints) {\n      this.points = args.points;\n      return this.smoothedPoints = args.smoothedPoints;\n    } else {\n      this.points = [];\n      results = [];\n      for (q = 0, len = points.length; q < len; q++) {\n        point = points[q];\n        results.push(this.addPoint(point));\n      }\n      return results;\n    }\n  },\n  getBoundingRect: function() {\n    return util.getBoundingRect(this.points.map(function(p) {\n      return {\n        x: p.x - p.size / 2,\n        y: p.y - p.size / 2,\n        width: p.size,\n        height: p.size\n      };\n    }));\n  },\n  toJSON: function() {\n    var p, point;\n    if (_doAllPointsShareStyle(this.points)) {\n      return {\n        order: this.order,\n        tailSize: this.tailSize,\n        smooth: this.smooth,\n        pointCoordinatePairs: (function() {\n          var len, q, ref2, results;\n          ref2 = this.points;\n          results = [];\n          for (q = 0, len = ref2.length; q < len; q++) {\n            point = ref2[q];\n            results.push([point.x, point.y]);\n          }\n          return results;\n        }).call(this),\n        smoothedPointCoordinatePairs: (function() {\n          var len, q, ref2, results;\n          ref2 = this.smoothedPoints;\n          results = [];\n          for (q = 0, len = ref2.length; q < len; q++) {\n            point = ref2[q];\n            results.push([point.x, point.y]);\n          }\n          return results;\n        }).call(this),\n        pointSize: this.points[0].size,\n        pointColor: this.points[0].color\n      };\n    } else {\n      return {\n        order: this.order,\n        tailSize: this.tailSize,\n        smooth: this.smooth,\n        points: (function() {\n          var len, q, ref2, results;\n          ref2 = this.points;\n          results = [];\n          for (q = 0, len = ref2.length; q < len; q++) {\n            p = ref2[q];\n            results.push(shapeToJSON(p));\n          }\n          return results;\n        }).call(this)\n      };\n    }\n  },\n  fromJSON: function(data) {\n    return _createLinePathFromData('LinePath', data);\n  },\n  addPoint: function(point) {\n    this.points.push(point);\n    if (!this.smooth) {\n      this.smoothedPoints = this.points;\n      return;\n    }\n    if (!this.smoothedPoints || this.points.length < this.sampleSize) {\n      return this.smoothedPoints = bspline(this.points, this.order);\n    } else {\n      this.tail = util.last(bspline(util.last(this.points, this.sampleSize), this.order), this.segmentSize * this.tailSize);\n      return this.smoothedPoints = this.smoothedPoints.slice(0, this.smoothedPoints.length - this.segmentSize * (this.tailSize - 1)).concat(this.tail);\n    }\n  },\n  move: function(moveInfo) {\n    var len, pt, pts, q;\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    if (!this.smooth) {\n      pts = this.points;\n    } else {\n      pts = this.smoothedPoints;\n    }\n    for (q = 0, len = pts.length; q < len; q++) {\n      pt = pts[q];\n      pt.move(moveInfo);\n    }\n    return this.points = this.smoothedPoints;\n  },\n  setUpperLeft: function(upperLeft) {\n    var br, xDiff, yDiff;\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    br = this.getBoundingRect();\n    xDiff = br.x - upperLeft.x;\n    yDiff = br.y - upperLeft.y;\n    return this.move({\n      xDiff: xDiff,\n      yDiff: yDiff\n    });\n  }\n};\n\nLinePath = defineShape('LinePath', linePathFuncs);\n\ndefineShape('ErasedLinePath', {\n  constructor: linePathFuncs.constructor,\n  toJSON: linePathFuncs.toJSON,\n  addPoint: linePathFuncs.addPoint,\n  getBoundingRect: linePathFuncs.getBoundingRect,\n  fromJSON: function(data) {\n    return _createLinePathFromData('ErasedLinePath', data);\n  }\n});\n\ndefineShape('Point', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.x = args.x || 0;\n    this.y = args.y || 0;\n    this.size = args.size || 0;\n    return this.color = args.color || '';\n  },\n  getBoundingRect: function() {\n    return {\n      x: this.x - this.size / 2,\n      y: this.y - this.size / 2,\n      width: this.size,\n      height: this.size\n    };\n  },\n  toJSON: function() {\n    return {\n      x: this.x,\n      y: this.y,\n      size: this.size,\n      color: this.color\n    };\n  },\n  fromJSON: function(data) {\n    return createShape('Point', data);\n  },\n  move: function(moveInfo) {\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    this.x = this.x - moveInfo.xDiff;\n    return this.y = this.y - moveInfo.yDiff;\n  },\n  setUpperLeft: function(upperLeft) {\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    this.x = upperLeft.x;\n    return this.y = upperLeft.y;\n  }\n});\n\ndefineShape('Polygon', {\n  constructor: function(args) {\n    var len, point, q, ref2, results;\n    if (args == null) {\n      args = {};\n    }\n    this.points = args.points;\n    this.fillColor = args.fillColor || 'white';\n    this.strokeColor = args.strokeColor || 'black';\n    this.strokeWidth = args.strokeWidth;\n    this.dash = args.dash || null;\n    if (args.isClosed == null) {\n      args.isClosed = true;\n    }\n    this.isClosed = args.isClosed;\n    ref2 = this.points;\n    results = [];\n    for (q = 0, len = ref2.length; q < len; q++) {\n      point = ref2[q];\n      point.color = this.strokeColor;\n      results.push(point.size = this.strokeWidth);\n    }\n    return results;\n  },\n  addPoint: function(x, y) {\n    return this.points.push(LC.createShape('Point', {\n      x: x,\n      y: y\n    }));\n  },\n  getBoundingRect: function() {\n    return util.getBoundingRect(this.points.map(function(p) {\n      return p.getBoundingRect();\n    }));\n  },\n  toJSON: function() {\n    return {\n      strokeWidth: this.strokeWidth,\n      fillColor: this.fillColor,\n      strokeColor: this.strokeColor,\n      dash: this.dash,\n      isClosed: this.isClosed,\n      pointCoordinatePairs: this.points.map(function(p) {\n        return [p.x, p.y];\n      })\n    };\n  },\n  fromJSON: function(data) {\n    data.points = data.pointCoordinatePairs.map(function(arg) {\n      var x, y;\n      x = arg[0], y = arg[1];\n      return createShape('Point', {\n        x: x,\n        y: y,\n        size: data.strokeWidth,\n        color: data.strokeColor\n      });\n    });\n    return createShape('Polygon', data);\n  },\n  move: function(moveInfo) {\n    var len, pt, q, ref2, results;\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    ref2 = this.points;\n    results = [];\n    for (q = 0, len = ref2.length; q < len; q++) {\n      pt = ref2[q];\n      results.push(pt.move(moveInfo));\n    }\n    return results;\n  },\n  setUpperLeft: function(upperLeft) {\n    var br, xDiff, yDiff;\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    br = this.getBoundingRect();\n    xDiff = br.x - upperLeft.x;\n    yDiff = br.y - upperLeft.y;\n    return this.move({\n      xDiff: xDiff,\n      yDiff: yDiff\n    });\n  }\n});\n\ndefineShape('Text', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.x = args.x || 0;\n    this.y = args.y || 0;\n    this.v = args.v || 0;\n    this.text = args.text || '';\n    this.color = args.color || 'black';\n    this.font = args.font || '18px sans-serif';\n    this.forcedWidth = args.forcedWidth || null;\n    return this.forcedHeight = args.forcedHeight || null;\n  },\n  _makeRenderer: function(ctx) {\n    ctx.lineHeight = 1.2;\n    this.renderer = new TextRenderer(ctx, this.text, this.font, this.forcedWidth, this.forcedHeight);\n    if (this.v < 1) {\n      console.log('repairing baseline');\n      this.v = 1;\n      this.x -= this.renderer.metrics.bounds.minx;\n      return this.y -= this.renderer.metrics.leading - this.renderer.metrics.descent;\n    }\n  },\n  setText: function(text) {\n    this.text = text;\n    return this.renderer = null;\n  },\n  setFont: function(font) {\n    this.font = font;\n    return this.renderer = null;\n  },\n  setPosition: function(x, y) {\n    this.x = x;\n    return this.y = y;\n  },\n  setSize: function(forcedWidth, forcedHeight) {\n    this.forcedWidth = Math.max(forcedWidth, 0);\n    this.forcedHeight = Math.max(forcedHeight, 0);\n    return this.renderer = null;\n  },\n  enforceMaxBoundingRect: function(lc) {\n    var br, dx, lcBoundingRect;\n    br = this.getBoundingRect(lc.ctx);\n    lcBoundingRect = {\n      x: -lc.position.x / lc.scale,\n      y: -lc.position.y / lc.scale,\n      width: lc.canvas.width / lc.scale,\n      height: lc.canvas.height / lc.scale\n    };\n    if (br.x + br.width > lcBoundingRect.x + lcBoundingRect.width) {\n      dx = br.x - lcBoundingRect.x;\n      this.forcedWidth = lcBoundingRect.width - dx - 10;\n      return this.renderer = null;\n    }\n  },\n  getBoundingRect: function(ctx, isEditing) {\n    if (isEditing == null) {\n      isEditing = false;\n    }\n    if (!this.renderer) {\n      if (ctx) {\n        this._makeRenderer(ctx);\n      } else {\n        throw \"Must pass ctx if text hasn't been rendered yet\";\n      }\n    }\n    return {\n      x: Math.floor(this.x),\n      y: Math.floor(this.y),\n      width: Math.ceil(this.renderer.getWidth(true)),\n      height: Math.ceil(this.renderer.getHeight())\n    };\n  },\n  toJSON: function() {\n    return {\n      x: this.x,\n      y: this.y,\n      text: this.text,\n      color: this.color,\n      font: this.font,\n      forcedWidth: this.forcedWidth,\n      forcedHeight: this.forcedHeight,\n      v: this.v\n    };\n  },\n  fromJSON: function(data) {\n    return createShape('Text', data);\n  },\n  move: function(moveInfo) {\n    if (moveInfo == null) {\n      moveInfo = {};\n    }\n    this.x = this.x - moveInfo.xDiff;\n    return this.y = this.y - moveInfo.yDiff;\n  },\n  setUpperLeft: function(upperLeft) {\n    if (upperLeft == null) {\n      upperLeft = {};\n    }\n    this.x = upperLeft.x;\n    return this.y = upperLeft.y;\n  }\n});\n\ndefineShape('SelectionBox', {\n  constructor: function(args) {\n    if (args == null) {\n      args = {};\n    }\n    this.shape = args.shape;\n    if (args.handleSize != null) {\n      this.handleSize = args.handleSize;\n    } else {\n      this.handleSize = 10;\n    }\n    this.margin = 4;\n    this.backgroundColor = args.backgroundColor || null;\n    return this._br = this.shape.getBoundingRect(args.ctx);\n  },\n  toJSON: function() {\n    return {\n      shape: shapeToJSON(this.shape),\n      backgroundColor: this.backgroundColor\n    };\n  },\n  fromJSON: function(arg) {\n    var backgroundColor, handleSize, margin, shape;\n    shape = arg.shape, handleSize = arg.handleSize, margin = arg.margin, backgroundColor = arg.backgroundColor;\n    return createShape('SelectionBox', {\n      shape: JSONToShape(shape),\n      backgroundColor: backgroundColor\n    });\n  },\n  getTopLeftHandleRect: function() {\n    return {\n      x: this._br.x - this.handleSize - this.margin,\n      y: this._br.y - this.handleSize - this.margin,\n      width: this.handleSize,\n      height: this.handleSize\n    };\n  },\n  getBottomLeftHandleRect: function() {\n    return {\n      x: this._br.x - this.handleSize - this.margin,\n      y: this._br.y + this._br.height + this.margin,\n      width: this.handleSize,\n      height: this.handleSize\n    };\n  },\n  getTopRightHandleRect: function() {\n    return {\n      x: this._br.x + this._br.width + this.margin,\n      y: this._br.y - this.handleSize - this.margin,\n      width: this.handleSize,\n      height: this.handleSize\n    };\n  },\n  getBottomRightHandleRect: function() {\n    return {\n      x: this._br.x + this._br.width + this.margin,\n      y: this._br.y + this._br.height + this.margin,\n      width: this.handleSize,\n      height: this.handleSize\n    };\n  },\n  getBoundingRect: function() {\n    return {\n      x: this._br.x - this.margin,\n      y: this._br.y - this.margin,\n      width: this._br.width + this.margin * 2,\n      height: this._br.height + this.margin * 2\n    };\n  }\n});\n\nmodule.exports = {\n  defineShape: defineShape,\n  createShape: createShape,\n  JSONToShape: JSONToShape,\n  shapeToJSON: shapeToJSON\n};\n\n\n},{\"./TextRenderer\":6,\"./canvasRenderer\":9,\"./lineEndCapShapes\":12,\"./svgRenderer\":18,\"./util\":19}],18:[function(require,module,exports){\nvar defineSVGRenderer, lineEndCapShapes, renderShapeToSVG, renderers;\n\nlineEndCapShapes = require('./lineEndCapShapes');\n\nrenderers = {};\n\ndefineSVGRenderer = function(shapeName, shapeToSVGFunc) {\n  return renderers[shapeName] = shapeToSVGFunc;\n};\n\nrenderShapeToSVG = function(shape, opts) {\n  if (opts == null) {\n    opts = {};\n  }\n  if (opts.shouldIgnoreUnsupportedShapes == null) {\n    opts.shouldIgnoreUnsupportedShapes = false;\n  }\n  if (renderers[shape.className]) {\n    return renderers[shape.className](shape);\n  } else if (opts.shouldIgnoreUnsupportedShapes) {\n    console.warn(\"Can't render shape of type \" + shape.className + \" to SVG\");\n    return \"\";\n  } else {\n    throw \"Can't render shape of type \" + shape.className + \" to SVG\";\n  }\n};\n\ndefineSVGRenderer('Rectangle', function(shape) {\n  var height, width, x, x1, x2, y, y1, y2;\n  x1 = shape.x;\n  y1 = shape.y;\n  x2 = shape.x + shape.width;\n  y2 = shape.y + shape.height;\n  x = Math.min(x1, x2);\n  y = Math.min(y1, y2);\n  width = Math.max(x1, x2) - x;\n  height = Math.max(y1, y2) - y;\n  if (shape.strokeWidth % 2 !== 0) {\n    x += 0.5;\n    y += 0.5;\n  }\n  return \"<rect x='\" + x + \"' y='\" + y + \"' width='\" + width + \"' height='\" + height + \"' stroke='\" + shape.strokeColor + \"' fill='\" + shape.fillColor + \"' stroke-width='\" + shape.strokeWidth + \"' />\";\n});\n\ndefineSVGRenderer('SelectionBox', function(shape) {\n  return \"\";\n});\n\ndefineSVGRenderer('Ellipse', function(shape) {\n  var centerX, centerY, halfHeight, halfWidth;\n  halfWidth = Math.floor(shape.width / 2);\n  halfHeight = Math.floor(shape.height / 2);\n  centerX = shape.x + halfWidth;\n  centerY = shape.y + halfHeight;\n  return \"<ellipse cx='\" + centerX + \"' cy='\" + centerY + \"' rx='\" + (Math.abs(halfWidth)) + \"' ry='\" + (Math.abs(halfHeight)) + \"' stroke='\" + shape.strokeColor + \"' fill='\" + shape.fillColor + \"' stroke-width='\" + shape.strokeWidth + \"' />\";\n});\n\ndefineSVGRenderer('Image', function(shape) {\n  return \"<image x='\" + shape.x + \"' y='\" + shape.y + \"' width='\" + (shape.image.naturalWidth * shape.scale) + \"' height='\" + (shape.image.naturalHeight * shape.scale) + \"' xlink:href='\" + shape.image.src + \"' />\";\n});\n\ndefineSVGRenderer('Line', function(shape) {\n  var arrowWidth, capString, dashString, x1, x2, y1, y2;\n  dashString = shape.dash ? \"stroke-dasharray='\" + (shape.dash.join(', ')) + \"'\" : '';\n  capString = '';\n  arrowWidth = Math.max(shape.strokeWidth * 2.2, 5);\n  x1 = shape.x1;\n  x2 = shape.x2;\n  y1 = shape.y1;\n  y2 = shape.y2;\n  if (shape.strokeWidth % 2 !== 0) {\n    x1 += 0.5;\n    x2 += 0.5;\n    y1 += 0.5;\n    y2 += 0.5;\n  }\n  if (shape.endCapShapes[0]) {\n    capString += lineEndCapShapes[shape.endCapShapes[0]].svg(x1, y1, Math.atan2(y1 - y2, x1 - x2), arrowWidth, shape.color);\n  }\n  if (shape.endCapShapes[1]) {\n    capString += lineEndCapShapes[shape.endCapShapes[1]].svg(x2, y2, Math.atan2(y2 - y1, x2 - x1), arrowWidth, shape.color);\n  }\n  return \"<g> <line x1='\" + x1 + \"' y1='\" + y1 + \"' x2='\" + x2 + \"' y2='\" + y2 + \"' \" + dashString + \" stroke-linecap='\" + shape.capStyle + \"' stroke='\" + shape.color + \" 'stroke-width='\" + shape.strokeWidth + \"' /> \" + capString + \" </g>\";\n});\n\ndefineSVGRenderer('LinePath', function(shape) {\n  return \"<polyline fill='none' points='\" + (shape.smoothedPoints.map(function(p) {\n    var offset;\n    offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n    return (p.x + offset) + \",\" + (p.y + offset);\n  }).join(' ')) + \"' stroke='\" + shape.points[0].color + \"' stroke-linecap='round' stroke-width='\" + shape.points[0].size + \"' />\";\n});\n\ndefineSVGRenderer('ErasedLinePath', function(shape) {\n  return \"\";\n});\n\ndefineSVGRenderer('Polygon', function(shape) {\n  if (shape.isClosed) {\n    return \"<polygon fill='\" + shape.fillColor + \"' points='\" + (shape.points.map(function(p) {\n      var offset;\n      offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n      return (p.x + offset) + \",\" + (p.y + offset);\n    }).join(' ')) + \"' stroke='\" + shape.strokeColor + \"' stroke-width='\" + shape.strokeWidth + \"' />\";\n  } else {\n    return \"<polyline fill='\" + shape.fillColor + \"' points='\" + (shape.points.map(function(p) {\n      var offset;\n      offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n      return (p.x + offset) + \",\" + (p.y + offset);\n    }).join(' ')) + \"' stroke='none' /> <polyline fill='none' points='\" + (shape.points.map(function(p) {\n      var offset;\n      offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n      return (p.x + offset) + \",\" + (p.y + offset);\n    }).join(' ')) + \"' stroke='\" + shape.strokeColor + \"' stroke-width='\" + shape.strokeWidth + \"' />\";\n  }\n});\n\ndefineSVGRenderer('Text', function(shape) {\n  var heightString, textSplitOnLines, widthString;\n  widthString = shape.forcedWidth ? \"width='\" + shape.forcedWidth + \"px'\" : \"\";\n  heightString = shape.forcedHeight ? \"height='\" + shape.forcedHeight + \"px'\" : \"\";\n  textSplitOnLines = shape.text.split(/\\r\\n|\\r|\\n/g);\n  if (shape.renderer) {\n    textSplitOnLines = shape.renderer.lines;\n  }\n  return \"<text x='\" + shape.x + \"' y='\" + shape.y + \"' \" + widthString + \" \" + heightString + \" fill='\" + shape.color + \"' style='font: \" + shape.font + \";'> \" + (textSplitOnLines.map((function(_this) {\n    return function(line, i) {\n      var dy;\n      dy = i === 0 ? 0 : '1.2em';\n      return \"<tspan x='\" + shape.x + \"' dy='\" + dy + \"' alignment-baseline='text-before-edge'> \" + line + \" </tspan>\";\n    };\n  })(this)).join('')) + \" </text>\";\n});\n\nmodule.exports = {\n  defineSVGRenderer: defineSVGRenderer,\n  renderShapeToSVG: renderShapeToSVG\n};\n\n\n},{\"./lineEndCapShapes\":12}],19:[function(require,module,exports){\nvar renderShapeToContext, renderShapeToSVG, slice, util,\n  slice1 = [].slice;\n\nslice = Array.prototype.slice;\n\nrenderShapeToContext = require('./canvasRenderer').renderShapeToContext;\n\nrenderShapeToSVG = require('./svgRenderer').renderShapeToSVG;\n\nutil = {\n  addImageOnload: function(img, fn) {\n    var oldOnload;\n    oldOnload = img.onload;\n    img.onload = function() {\n      if (typeof oldOnload === \"function\") {\n        oldOnload();\n      }\n      return fn();\n    };\n    return img;\n  },\n  last: function(array, n) {\n    if (n == null) {\n      n = null;\n    }\n    if (n) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  },\n  classSet: function(classNameToIsPresent) {\n    var classNames, key;\n    classNames = [];\n    for (key in classNameToIsPresent) {\n      if (classNameToIsPresent[key]) {\n        classNames.push(key);\n      }\n    }\n    return classNames.join(' ');\n  },\n  matchElementSize: function(elementToMatch, elementsToResize, scale, callback) {\n    var resize;\n    if (callback == null) {\n      callback = function() {};\n    }\n    resize = (function(_this) {\n      return function() {\n        var el, i, len;\n        for (i = 0, len = elementsToResize.length; i < len; i++) {\n          el = elementsToResize[i];\n          el.style.width = elementToMatch.offsetWidth + \"px\";\n          el.style.height = elementToMatch.offsetHeight + \"px\";\n          if (el.width != null) {\n            el.setAttribute('width', el.offsetWidth * scale);\n            el.setAttribute('height', el.offsetHeight * scale);\n          }\n        }\n        return callback();\n      };\n    })(this);\n    elementToMatch.addEventListener('resize', resize);\n    window.addEventListener('resize', resize);\n    window.addEventListener('orientationchange', resize);\n    resize();\n    return resize;\n  },\n  combineCanvases: function() {\n    var c, canvas, canvases, ctx, i, j, len, len1;\n    canvases = 1 <= arguments.length ? slice1.call(arguments, 0) : [];\n    c = document.createElement('canvas');\n    c.width = canvases[0].width;\n    c.height = canvases[0].height;\n    for (i = 0, len = canvases.length; i < len; i++) {\n      canvas = canvases[i];\n      c.width = Math.max(canvas.width, c.width);\n      c.height = Math.max(canvas.height, c.height);\n    }\n    ctx = c.getContext('2d');\n    for (j = 0, len1 = canvases.length; j < len1; j++) {\n      canvas = canvases[j];\n      ctx.drawImage(canvas, 0, 0);\n    }\n    return c;\n  },\n  renderShapes: function(shapes, bounds, scale, canvas) {\n    var ctx, i, len, shape;\n    if (scale == null) {\n      scale = 1;\n    }\n    if (canvas == null) {\n      canvas = null;\n    }\n    canvas = canvas || document.createElement('canvas');\n    canvas.width = bounds.width * scale;\n    canvas.height = bounds.height * scale;\n    ctx = canvas.getContext('2d');\n    ctx.translate(-bounds.x * scale, -bounds.y * scale);\n    ctx.scale(scale, scale);\n    for (i = 0, len = shapes.length; i < len; i++) {\n      shape = shapes[i];\n      renderShapeToContext(ctx, shape);\n    }\n    return canvas;\n  },\n  renderShapesToSVG: function(shapes, arg, backgroundColor) {\n    var height, width, x, y;\n    x = arg.x, y = arg.y, width = arg.width, height = arg.height;\n    return (\"<svg xmlns='http://www.w3.org/2000/svg' width='\" + width + \"' height='\" + height + \"' viewBox='0 0 \" + width + \" \" + height + \"'> <rect width='\" + width + \"' height='\" + height + \"' x='0' y='0' fill='\" + backgroundColor + \"' /> <g transform='translate(\" + (-x) + \", \" + (-y) + \")'> \" + (shapes.map(renderShapeToSVG).join('')) + \" </g> </svg>\").replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n  },\n  getBoundingRect: function(rects, width, height) {\n    var i, len, maxX, maxY, minX, minY, rect;\n    if (!rects.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0 || width,\n        height: 0 || height\n      };\n    }\n    minX = rects[0].x;\n    minY = rects[0].y;\n    maxX = rects[0].x + rects[0].width;\n    maxY = rects[0].y + rects[0].height;\n    for (i = 0, len = rects.length; i < len; i++) {\n      rect = rects[i];\n      minX = Math.floor(Math.min(rect.x, minX));\n      minY = Math.floor(Math.min(rect.y, minY));\n      maxX = Math.ceil(Math.max(maxX, rect.x + rect.width));\n      maxY = Math.ceil(Math.max(maxY, rect.y + rect.height));\n    }\n    minX = width ? 0 : minX;\n    minY = height ? 0 : minY;\n    maxX = width || maxX;\n    maxY = height || maxY;\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n  getDefaultImageRect: function(shapeBoundingRects, explicitSize, margin) {\n    var height, rect, width;\n    if (explicitSize == null) {\n      explicitSize = {\n        width: 0,\n        height: 0\n      };\n    }\n    if (margin == null) {\n      margin = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n    }\n    width = explicitSize.width, height = explicitSize.height;\n    rect = util.getBoundingRect(shapeBoundingRects, width === 'infinite' ? 0 : width, height === 'infinite' ? 0 : height);\n    rect.x -= margin.left;\n    rect.y -= margin.top;\n    rect.width += margin.left + margin.right;\n    rect.height += margin.top + margin.bottom;\n    return rect;\n  },\n  getBackingScale: function(context) {\n    if (window.devicePixelRatio == null) {\n      return 1;\n    }\n    if (!(window.devicePixelRatio > 1)) {\n      return 1;\n    }\n    return window.devicePixelRatio;\n  },\n  requestAnimationFrame: (window.requestAnimationFrame || window.setTimeout).bind(window),\n  getGUID: (function() {\n    var s4;\n    s4 = function() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    };\n    return function() {\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    };\n  })(),\n  requestAnimationFrame: function(f) {\n    if (window.requestAnimationFrame) {\n      return window.requestAnimationFrame(f);\n    }\n    if (window.webkitRequestAnimationFrame) {\n      return window.webkitRequestAnimationFrame(f);\n    }\n    if (window.mozRequestAnimationFrame) {\n      return window.mozRequestAnimationFrame(f);\n    }\n    return setTimeout(f, 0);\n  },\n  cancelAnimationFrame: function(f) {\n    if (window.cancelAnimationFrame) {\n      return window.cancelAnimationFrame(f);\n    }\n    if (window.webkitCancelRequestAnimationFrame) {\n      return window.webkitCancelRequestAnimationFrame(f);\n    }\n    if (window.webkitCancelAnimationFrame) {\n      return window.webkitCancelAnimationFrame(f);\n    }\n    if (window.mozCancelAnimationFrame) {\n      return window.mozCancelAnimationFrame(f);\n    }\n    return clearTimeout(f);\n  }\n};\n\nmodule.exports = util;\n\n\n},{\"./canvasRenderer\":9,\"./svgRenderer\":18}],20:[function(require,module,exports){\n'use strict';\n\n(function () {\n  function CustomEvent(event, params) {\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n\n  CustomEvent.prototype = window.CustomEvent.prototype;\n\n  window.CustomEvent = CustomEvent;\n})();\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\n\nvar hasWarned = false;\nif (!CanvasRenderingContext2D.prototype.setLineDash) {\n  CanvasRenderingContext2D.prototype.setLineDash = function () {\n    // no-op\n    if (!hasWarned) {\n      console.warn(\"context2D.setLineDash is a no-op in this browser.\");\n      hasWarned = true;\n    }\n  };\n}\nmodule.exports = null;\n\n},{}],22:[function(require,module,exports){\nvar LiterallyCanvasModel, LiterallyCanvasReactComponent, baseTools, canvasRenderer, conversion, defaultImageURLPrefix, defaultOptions, defaultTools, defineOptionsStyle, init, initReactDOM, initWithoutGUI, localize, registerJQueryPlugin, renderSnapshotToImage, renderSnapshotToSVG, setDefaultImageURLPrefix, shapes, svgRenderer, tools, util;\n\nrequire('./ie_customevent');\n\nrequire('./ie_setLineDash');\n\nLiterallyCanvasModel = require('./core/LiterallyCanvas');\n\ndefaultOptions = require('./core/defaultOptions');\n\ncanvasRenderer = require('./core/canvasRenderer');\n\nsvgRenderer = require('./core/svgRenderer');\n\nshapes = require('./core/shapes');\n\nutil = require('./core/util');\n\nrenderSnapshotToImage = require('./core/renderSnapshotToImage');\n\nrenderSnapshotToSVG = require('./core/renderSnapshotToSVG');\n\nlocalize = require('./core/localization').localize;\n\nLiterallyCanvasReactComponent = require('./reactGUI/LiterallyCanvas');\n\ninitReactDOM = require('./reactGUI/initDOM');\n\nrequire('./optionsStyles/font');\n\nrequire('./optionsStyles/stroke-width');\n\nrequire('./optionsStyles/line-options-and-stroke-width');\n\nrequire('./optionsStyles/polygon-and-stroke-width');\n\nrequire('./optionsStyles/stroke-or-fill');\n\nrequire('./optionsStyles/null');\n\ndefineOptionsStyle = require('./optionsStyles/optionsStyles').defineOptionsStyle;\n\nconversion = {\n  snapshotToShapes: function(snapshot) {\n    var i, len, ref, results, shape;\n    ref = snapshot.shapes;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      shape = ref[i];\n      results.push(shapes.JSONToShape(shape));\n    }\n    return results;\n  },\n  snapshotJSONToShapes: function(json) {\n    return conversion.snapshotToShapes(JSON.parse(json));\n  }\n};\n\nbaseTools = require('./tools/base');\n\ntools = {\n  Pencil: require('./tools/Pencil'),\n  Eraser: require('./tools/Eraser'),\n  Line: require('./tools/Line'),\n  Rectangle: require('./tools/Rectangle'),\n  Ellipse: require('./tools/Ellipse'),\n  Text: require('./tools/Text'),\n  Polygon: require('./tools/Polygon'),\n  Pan: require('./tools/Pan'),\n  Eyedropper: require('./tools/Eyedropper'),\n  SelectShape: require('./tools/SelectShape'),\n  Tool: baseTools.Tool,\n  ToolWithStroke: baseTools.ToolWithStroke\n};\n\ndefaultTools = defaultOptions.tools;\n\ndefaultImageURLPrefix = defaultOptions.imageURLPrefix;\n\nsetDefaultImageURLPrefix = function(newDefault) {\n  defaultImageURLPrefix = newDefault;\n  return defaultOptions.imageURLPrefix = newDefault;\n};\n\ninit = function(el, opts) {\n  var child, i, len, opt, ref;\n  if (opts == null) {\n    opts = {};\n  }\n  for (opt in defaultOptions) {\n    if (!(opt in opts)) {\n      opts[opt] = defaultOptions[opt];\n    }\n  }\n  ref = el.children;\n  for (i = 0, len = ref.length; i < len; i++) {\n    child = ref[i];\n    el.removeChild(child);\n  }\n  return require('./reactGUI/initDOM')(el, opts);\n};\n\ninitWithoutGUI = function(el, opts) {\n  var drawingViewElement, lc, originalClassName;\n  originalClassName = el.className;\n  if ([' ', ' '].join(el.className).indexOf(' literally ') === -1) {\n    el.className = el.className + ' literally';\n  }\n  el.className = el.className + ' toolbar-hidden';\n  drawingViewElement = document.createElement('div');\n  drawingViewElement.className = 'lc-drawing';\n  el.appendChild(drawingViewElement);\n  lc = new LiterallyCanvasModel(drawingViewElement, opts);\n  lc.teardown = function() {\n    var child, i, len, ref;\n    lc._teardown();\n    ref = el.children;\n    for (i = 0, len = ref.length; i < len; i++) {\n      child = ref[i];\n      el.removeChild(child);\n    }\n    return el.className = originalClassName;\n  };\n  if ('onInit' in opts) {\n    opts.onInit(lc);\n  }\n  return lc;\n};\n\nregisterJQueryPlugin = function(_$) {\n  return _$.fn.literallycanvas = function(opts) {\n    if (opts == null) {\n      opts = {};\n    }\n    this.each((function(_this) {\n      return function(ix, el) {\n        return el.literallycanvas = init(el, opts);\n      };\n    })(this));\n    return this;\n  };\n};\n\nif (typeof window !== 'undefined') {\n  window.LC = {\n    init: init\n  };\n  if (window.$) {\n    registerJQueryPlugin(window.$);\n  }\n}\n\nmodule.exports = {\n  init: init,\n  registerJQueryPlugin: registerJQueryPlugin,\n  util: util,\n  tools: tools,\n  setDefaultImageURLPrefix: setDefaultImageURLPrefix,\n  defaultTools: defaultTools,\n  defineOptionsStyle: defineOptionsStyle,\n  LiterallyCanvasReactComponent: LiterallyCanvasReactComponent,\n  defineShape: shapes.defineShape,\n  createShape: shapes.createShape,\n  JSONToShape: shapes.JSONToShape,\n  shapeToJSON: shapes.shapeToJSON,\n  defineCanvasRenderer: canvasRenderer.defineCanvasRenderer,\n  renderShapeToContext: canvasRenderer.renderShapeToContext,\n  renderShapeToCanvas: canvasRenderer.renderShapeToCanvas,\n  renderShapesToCanvas: util.renderShapes,\n  defineSVGRenderer: svgRenderer.defineSVGRenderer,\n  renderShapeToSVG: svgRenderer.renderShapeToSVG,\n  renderShapesToSVG: util.renderShapesToSVG,\n  snapshotToShapes: conversion.snapshotToShapes,\n  snapshotJSONToShapes: conversion.snapshotJSONToShapes,\n  renderSnapshotToImage: renderSnapshotToImage,\n  renderSnapshotToSVG: renderSnapshotToSVG,\n  localize: localize\n};\n\n\n},{\"./core/LiterallyCanvas\":5,\"./core/canvasRenderer\":9,\"./core/defaultOptions\":10,\"./core/localization\":13,\"./core/renderSnapshotToImage\":15,\"./core/renderSnapshotToSVG\":16,\"./core/shapes\":17,\"./core/svgRenderer\":18,\"./core/util\":19,\"./ie_customevent\":20,\"./ie_setLineDash\":21,\"./optionsStyles/font\":23,\"./optionsStyles/line-options-and-stroke-width\":24,\"./optionsStyles/null\":25,\"./optionsStyles/optionsStyles\":26,\"./optionsStyles/polygon-and-stroke-width\":27,\"./optionsStyles/stroke-or-fill\":28,\"./optionsStyles/stroke-width\":29,\"./reactGUI/LiterallyCanvas\":32,\"./reactGUI/initDOM\":42,\"./tools/Ellipse\":43,\"./tools/Eraser\":44,\"./tools/Eyedropper\":45,\"./tools/Line\":46,\"./tools/Pan\":47,\"./tools/Pencil\":48,\"./tools/Polygon\":49,\"./tools/Rectangle\":50,\"./tools/SelectShape\":51,\"./tools/Text\":52,\"./tools/base\":53}],23:[function(require,module,exports){\nvar ALL_FONTS, FONT_NAME_TO_VALUE, MONOSPACE_FONTS, OTHER_FONTS, React, SANS_SERIF_FONTS, SERIF_FONTS, _, defineOptionsStyle, i, j, l, len, len1, len2, len3, m, name, ref, ref1, ref2, ref3, value;\n\nReact = require('../reactGUI/React-shim');\n\ndefineOptionsStyle = require('./optionsStyles').defineOptionsStyle;\n\n_ = require('../core/localization')._;\n\nSANS_SERIF_FONTS = [['Arial', 'Arial,\"Helvetica Neue\",Helvetica,sans-serif'], ['Arial Black', '\"Arial Black\",\"Arial Bold\",Gadget,sans-serif'], ['Arial Narrow', '\"Arial Narrow\",Arial,sans-serif'], ['Gill Sans', '\"Gill Sans\",\"Gill Sans MT\",Calibri,sans-serif'], ['Helvetica', '\"Helvetica Neue\",Helvetica,Arial,sans-serif'], ['Impact', 'Impact,Haettenschweiler,\"Franklin Gothic Bold\",Charcoal,\"Helvetica Inserat\",\"Bitstream Vera Sans Bold\",\"Arial Black\",sans-serif'], ['Tahoma', 'Tahoma,Verdana,Segoe,sans-serif'], ['Trebuchet MS', '\"Trebuchet MS\",\"Lucida Grande\",\"Lucida Sans Unicode\",\"Lucida Sans\",Tahoma,sans-serif'], ['Verdana', 'Verdana,Geneva,sans-serif']].map(function(arg) {\n  var name, value;\n  name = arg[0], value = arg[1];\n  return {\n    name: _(name),\n    value: value\n  };\n});\n\nSERIF_FONTS = [['Baskerville', 'Baskerville,\"Baskerville Old Face\",\"Hoefler Text\",Garamond,\"Times New Roman\",serif'], ['Garamond', 'Garamond,Baskerville,\"Baskerville Old Face\",\"Hoefler Text\",\"Times New Roman\",serif'], ['Georgia', 'Georgia,Times,\"Times New Roman\",serif'], ['Hoefler Text', '\"Hoefler Text\",\"Baskerville Old Face\",Garamond,\"Times New Roman\",serif'], ['Lucida Bright', '\"Lucida Bright\",Georgia,serif'], ['Palatino', 'Palatino,\"Palatino Linotype\",\"Palatino LT STD\",\"Book Antiqua\",Georgia,serif'], ['Times New Roman', 'TimesNewRoman,\"Times New Roman\",Times,Baskerville,Georgia,serif']].map(function(arg) {\n  var name, value;\n  name = arg[0], value = arg[1];\n  return {\n    name: _(name),\n    value: value\n  };\n});\n\nMONOSPACE_FONTS = [['Consolas/Monaco', 'Consolas,monaco,\"Lucida Console\",monospace'], ['Courier New', '\"Courier New\",Courier,\"Lucida Sans Typewriter\",\"Lucida Typewriter\",monospace'], ['Lucida Sans Typewriter', '\"Lucida Sans Typewriter\",\"Lucida Console\",monaco,\"Bitstream Vera Sans Mono\",monospace']].map(function(arg) {\n  var name, value;\n  name = arg[0], value = arg[1];\n  return {\n    name: _(name),\n    value: value\n  };\n});\n\nOTHER_FONTS = [['Copperplate', 'Copperplate,\"Copperplate Gothic Light\",fantasy'], ['Papyrus', 'Papyrus,fantasy'], ['Script', '\"Brush Script MT\",cursive']].map(function(arg) {\n  var name, value;\n  name = arg[0], value = arg[1];\n  return {\n    name: _(name),\n    value: value\n  };\n});\n\nALL_FONTS = [[_('Sans Serif'), SANS_SERIF_FONTS], [_('Serif'), SERIF_FONTS], [_('Monospace'), MONOSPACE_FONTS], [_('Other'), OTHER_FONTS]];\n\nFONT_NAME_TO_VALUE = {};\n\nfor (i = 0, len = SANS_SERIF_FONTS.length; i < len; i++) {\n  ref = SANS_SERIF_FONTS[i], name = ref.name, value = ref.value;\n  FONT_NAME_TO_VALUE[name] = value;\n}\n\nfor (j = 0, len1 = SERIF_FONTS.length; j < len1; j++) {\n  ref1 = SERIF_FONTS[j], name = ref1.name, value = ref1.value;\n  FONT_NAME_TO_VALUE[name] = value;\n}\n\nfor (l = 0, len2 = MONOSPACE_FONTS.length; l < len2; l++) {\n  ref2 = MONOSPACE_FONTS[l], name = ref2.name, value = ref2.value;\n  FONT_NAME_TO_VALUE[name] = value;\n}\n\nfor (m = 0, len3 = OTHER_FONTS.length; m < len3; m++) {\n  ref3 = OTHER_FONTS[m], name = ref3.name, value = ref3.value;\n  FONT_NAME_TO_VALUE[name] = value;\n}\n\ndefineOptionsStyle('font', React.createClass({\n  displayName: 'FontOptions',\n  getInitialState: function() {\n    return {\n      isItalic: false,\n      isBold: false,\n      fontName: 'Helvetica',\n      fontSizeIndex: 4\n    };\n  },\n  getFontSizes: function() {\n    return [9, 10, 12, 14, 18, 24, 36, 48, 64, 72, 96, 144, 288];\n  },\n  updateTool: function(newState) {\n    var fontSize, items, k;\n    if (newState == null) {\n      newState = {};\n    }\n    for (k in this.state) {\n      if (!(k in newState)) {\n        newState[k] = this.state[k];\n      }\n    }\n    fontSize = this.getFontSizes()[newState.fontSizeIndex];\n    items = [];\n    if (newState.isItalic) {\n      items.push('italic');\n    }\n    if (newState.isBold) {\n      items.push('bold');\n    }\n    items.push(fontSize + \"px\");\n    items.push(FONT_NAME_TO_VALUE[newState.fontName]);\n    this.props.lc.tool.font = items.join(' ');\n    return this.props.lc.trigger('setFont', items.join(' '));\n  },\n  handleFontSize: function(event) {\n    var newState;\n    newState = {\n      fontSizeIndex: event.target.value\n    };\n    this.setState(newState);\n    return this.updateTool(newState);\n  },\n  handleFontFamily: function(event) {\n    var newState;\n    newState = {\n      fontName: event.target.selectedOptions[0].innerHTML\n    };\n    this.setState(newState);\n    return this.updateTool(newState);\n  },\n  handleItalic: function(event) {\n    var newState;\n    newState = {\n      isItalic: !this.state.isItalic\n    };\n    this.setState(newState);\n    return this.updateTool(newState);\n  },\n  handleBold: function(event) {\n    var newState;\n    newState = {\n      isBold: !this.state.isBold\n    };\n    this.setState(newState);\n    return this.updateTool(newState);\n  },\n  componentDidMount: function() {\n    return this.updateTool();\n  },\n  render: function() {\n    var br, div, input, label, lc, optgroup, option, ref4, select, span;\n    lc = this.props.lc;\n    ref4 = React.DOM, div = ref4.div, input = ref4.input, select = ref4.select, option = ref4.option, br = ref4.br, label = ref4.label, span = ref4.span, optgroup = ref4.optgroup;\n    return div({\n      className: 'lc-font-settings'\n    }, select({\n      value: this.state.fontSizeIndex,\n      onChange: this.handleFontSize\n    }, this.getFontSizes().map((function(_this) {\n      return function(size, ix) {\n        return option({\n          value: ix,\n          key: ix\n        }, size + \"px\");\n      };\n    })(this))), select({\n      value: this.state.fontName,\n      onChange: this.handleFontFamily\n    }, ALL_FONTS.map((function(_this) {\n      return function(arg) {\n        var fonts, label;\n        label = arg[0], fonts = arg[1];\n        return optgroup({\n          key: label,\n          label: label\n        }, fonts.map(function(family, ix) {\n          return option({\n            value: family.name,\n            key: ix\n          }, family.name);\n        }));\n      };\n    })(this))), span({}, label({\n      htmlFor: 'italic'\n    }, _(\"italic\")), input({\n      type: 'checkbox',\n      id: 'italic',\n      checked: this.state.isItalic,\n      onChange: this.handleItalic\n    })), span({}, label({\n      htmlFor: 'bold'\n    }, _(\"bold\")), input({\n      type: 'checkbox',\n      id: 'bold',\n      checked: this.state.isBold,\n      onChange: this.handleBold\n    })));\n  }\n}));\n\nmodule.exports = {};\n\n\n},{\"../core/localization\":13,\"../reactGUI/React-shim\":35,\"./optionsStyles\":26}],24:[function(require,module,exports){\nvar React, StrokeWidthPicker, classSet, createSetStateOnEventMixin, defineOptionsStyle;\n\nReact = require('../reactGUI/React-shim');\n\ndefineOptionsStyle = require('./optionsStyles').defineOptionsStyle;\n\nStrokeWidthPicker = React.createFactory(require('../reactGUI/StrokeWidthPicker'));\n\ncreateSetStateOnEventMixin = require('../reactGUI/createSetStateOnEventMixin');\n\nclassSet = require('../core/util').classSet;\n\ndefineOptionsStyle('line-options-and-stroke-width', React.createClass({\n  displayName: 'LineOptionsAndStrokeWidth',\n  getState: function() {\n    return {\n      strokeWidth: this.props.tool.strokeWidth,\n      isDashed: this.props.tool.isDashed,\n      hasEndArrow: this.props.tool.hasEndArrow\n    };\n  },\n  getInitialState: function() {\n    return this.getState();\n  },\n  mixins: [createSetStateOnEventMixin('toolChange')],\n  render: function() {\n    var arrowButtonClass, dashButtonClass, div, img, li, ref, style, toggleIsDashed, togglehasEndArrow, ul;\n    ref = React.DOM, div = ref.div, ul = ref.ul, li = ref.li, img = ref.img;\n    toggleIsDashed = (function(_this) {\n      return function() {\n        _this.props.tool.isDashed = !_this.props.tool.isDashed;\n        return _this.setState(_this.getState());\n      };\n    })(this);\n    togglehasEndArrow = (function(_this) {\n      return function() {\n        _this.props.tool.hasEndArrow = !_this.props.tool.hasEndArrow;\n        return _this.setState(_this.getState());\n      };\n    })(this);\n    dashButtonClass = classSet({\n      'square-toolbar-button': true,\n      'selected': this.state.isDashed\n    });\n    arrowButtonClass = classSet({\n      'square-toolbar-button': true,\n      'selected': this.state.hasEndArrow\n    });\n    style = {\n      float: 'left',\n      margin: 1\n    };\n    return div({}, div({\n      className: dashButtonClass,\n      onClick: toggleIsDashed,\n      style: style\n    }, img({\n      src: this.props.imageURLPrefix + \"/dashed-line.png\"\n    })), div({\n      className: arrowButtonClass,\n      onClick: togglehasEndArrow,\n      style: style\n    }, img({\n      src: this.props.imageURLPrefix + \"/line-with-arrow.png\"\n    })), StrokeWidthPicker({\n      tool: this.props.tool,\n      lc: this.props.lc\n    }));\n  }\n}));\n\nmodule.exports = {};\n\n\n},{\"../core/util\":19,\"../reactGUI/React-shim\":35,\"../reactGUI/StrokeWidthPicker\":37,\"../reactGUI/createSetStateOnEventMixin\":40,\"./optionsStyles\":26}],25:[function(require,module,exports){\nvar React, defineOptionsStyle;\n\nReact = require('../reactGUI/React-shim');\n\ndefineOptionsStyle = require('./optionsStyles').defineOptionsStyle;\n\ndefineOptionsStyle('null', React.createClass({\n  displayName: 'NoOptions',\n  render: function() {\n    return React.DOM.div();\n  }\n}));\n\nmodule.exports = {};\n\n\n},{\"../reactGUI/React-shim\":35,\"./optionsStyles\":26}],26:[function(require,module,exports){\nvar React, defineOptionsStyle, optionsStyles;\n\nReact = require('../reactGUI/React-shim');\n\noptionsStyles = {};\n\ndefineOptionsStyle = function(name, style) {\n  return optionsStyles[name] = React.createFactory(style);\n};\n\nmodule.exports = {\n  optionsStyles: optionsStyles,\n  defineOptionsStyle: defineOptionsStyle\n};\n\n\n},{\"../reactGUI/React-shim\":35}],27:[function(require,module,exports){\nvar React, StrokeWidthPicker, createSetStateOnEventMixin, defineOptionsStyle;\n\nReact = require('../reactGUI/React-shim');\n\ndefineOptionsStyle = require('./optionsStyles').defineOptionsStyle;\n\nStrokeWidthPicker = React.createFactory(require('../reactGUI/StrokeWidthPicker'));\n\ncreateSetStateOnEventMixin = require('../reactGUI/createSetStateOnEventMixin');\n\ndefineOptionsStyle('polygon-and-stroke-width', React.createClass({\n  displayName: 'PolygonAndStrokeWidth',\n  getState: function() {\n    return {\n      strokeWidth: this.props.tool.strokeWidth,\n      inProgress: false\n    };\n  },\n  getInitialState: function() {\n    return this.getState();\n  },\n  mixins: [createSetStateOnEventMixin('toolChange')],\n  componentDidMount: function() {\n    var hidePolygonTools, showPolygonTools, unsubscribeFuncs;\n    unsubscribeFuncs = [];\n    this.unsubscribe = (function(_this) {\n      return function() {\n        var func, i, len, results;\n        results = [];\n        for (i = 0, len = unsubscribeFuncs.length; i < len; i++) {\n          func = unsubscribeFuncs[i];\n          results.push(func());\n        }\n        return results;\n      };\n    })(this);\n    showPolygonTools = (function(_this) {\n      return function() {\n        if (!_this.state.inProgress) {\n          return _this.setState({\n            inProgress: true\n          });\n        }\n      };\n    })(this);\n    hidePolygonTools = (function(_this) {\n      return function() {\n        return _this.setState({\n          inProgress: false\n        });\n      };\n    })(this);\n    unsubscribeFuncs.push(this.props.lc.on('lc-polygon-started', showPolygonTools));\n    return unsubscribeFuncs.push(this.props.lc.on('lc-polygon-stopped', hidePolygonTools));\n  },\n  componentWillUnmount: function() {\n    return this.unsubscribe();\n  },\n  render: function() {\n    var div, img, lc, polygonCancel, polygonFinishClosed, polygonFinishOpen, polygonToolStyle, ref;\n    lc = this.props.lc;\n    ref = React.DOM, div = ref.div, img = ref.img;\n    polygonFinishOpen = (function(_this) {\n      return function() {\n        return lc.trigger('lc-polygon-finishopen');\n      };\n    })(this);\n    polygonFinishClosed = (function(_this) {\n      return function() {\n        return lc.trigger('lc-polygon-finishclosed');\n      };\n    })(this);\n    polygonCancel = (function(_this) {\n      return function() {\n        return lc.trigger('lc-polygon-cancel');\n      };\n    })(this);\n    polygonToolStyle = {};\n    if (!this.state.inProgress) {\n      polygonToolStyle = {\n        display: 'none'\n      };\n    }\n    return div({}, div({\n      className: 'polygon-toolbar horz-toolbar',\n      style: polygonToolStyle\n    }, div({\n      className: 'square-toolbar-button',\n      onClick: polygonFinishOpen\n    }, img({\n      src: this.props.imageURLPrefix + \"/polygon-open.png\"\n    })), div({\n      className: 'square-toolbar-button',\n      onClick: polygonFinishClosed\n    }, img({\n      src: this.props.imageURLPrefix + \"/polygon-closed.png\"\n    })), div({\n      className: 'square-toolbar-button',\n      onClick: polygonCancel\n    }, img({\n      src: this.props.imageURLPrefix + \"/polygon-cancel.png\"\n    }))), div({}, StrokeWidthPicker({\n      tool: this.props.tool,\n      lc: this.props.lc\n    })));\n  }\n}));\n\nmodule.exports = {};\n\n\n},{\"../reactGUI/React-shim\":35,\"../reactGUI/StrokeWidthPicker\":37,\"../reactGUI/createSetStateOnEventMixin\":40,\"./optionsStyles\":26}],28:[function(require,module,exports){\n'use strict';\n\nvar React = require('../reactGUI/React-shim');\n\nvar _require = require('./optionsStyles');\n\nvar defineOptionsStyle = _require.defineOptionsStyle;\n\nvar createSetStateOnEventMixin = require('../reactGUI/createSetStateOnEventMixin');\nvar _ = require('../core/localization')._;\n\ndefineOptionsStyle('stroke-or-fill', React.createClass({\n  displayName: 'StrokeOrFillPicker',\n  getState: function getState() {\n    return { strokeOrFill: 'stroke' };\n  },\n  getInitialState: function getInitialState() {\n    return this.getState();\n  },\n  mixins: [createSetStateOnEventMixin('toolChange')],\n\n  onChange: function onChange(e) {\n    if (e.target.id == 'stroke-or-fill-stroke') {\n      this.props.lc.tool.strokeOrFill = 'stroke';\n    } else {\n      this.props.lc.tool.strokeOrFill = 'fill';\n    }\n    this.setState(this.getState());\n  },\n\n  render: function render() {\n    var lc = this.props.lc;\n\n    return React.createElement(\n      'form',\n      null,\n      React.createElement(\n        'span',\n        null,\n        ' ',\n        _('Color to change:'),\n        ' '\n      ),\n      React.createElement(\n        'span',\n        null,\n        React.createElement('input', { type: 'radio', name: 'stroke-or-fill', value: 'stroke',\n          id: 'stroke-or-fill-stroke', onChange: this.onChange,\n          checked: lc.tool.strokeOrFill == 'stroke' }),\n        React.createElement(\n          'label',\n          { htmlFor: 'stroke-or-fill-stroke', className: 'label' },\n          ' ',\n          _(\"stroke\")\n        )\n      ),\n      React.createElement(\n        'span',\n        null,\n        React.createElement('input', { type: 'radio', name: 'stroke-or-fill', value: 'fill',\n          id: 'stroke-or-fill-fill', onChange: this.onChange,\n          checked: lc.tool.strokeOrFill == 'fill' }),\n        React.createElement(\n          'label',\n          { htmlFor: 'stroke-or-fill-fill', className: 'label' },\n          ' ',\n          _(\"fill\")\n        )\n      )\n    );\n  }\n}));\n\nmodule.exports = {};\n\n},{\"../core/localization\":13,\"../reactGUI/React-shim\":35,\"../reactGUI/createSetStateOnEventMixin\":40,\"./optionsStyles\":26}],29:[function(require,module,exports){\nvar StrokeWidthPicker, defineOptionsStyle;\n\ndefineOptionsStyle = require('./optionsStyles').defineOptionsStyle;\n\nStrokeWidthPicker = require('../reactGUI/StrokeWidthPicker');\n\ndefineOptionsStyle('stroke-width', StrokeWidthPicker);\n\nmodule.exports = {};\n\n\n},{\"../reactGUI/StrokeWidthPicker\":37,\"./optionsStyles\":26}],30:[function(require,module,exports){\nvar ClearButton, React, _, classSet, createSetStateOnEventMixin;\n\nReact = require('./React-shim');\n\ncreateSetStateOnEventMixin = require('./createSetStateOnEventMixin');\n\n_ = require('../core/localization')._;\n\nclassSet = require('../core/util').classSet;\n\nClearButton = React.createClass({\n  displayName: 'ClearButton',\n  getState: function() {\n    return {\n      isEnabled: this.props.lc.canUndo()\n    };\n  },\n  getInitialState: function() {\n    return this.getState();\n  },\n  mixins: [createSetStateOnEventMixin('drawingChange')],\n  render: function() {\n    var className, div, lc, onClick;\n    div = React.DOM.div;\n    lc = this.props.lc;\n    className = classSet({\n      'lc-clear': true,\n      'toolbar-button': true,\n      'fat-button': true,\n      'disabled': !this.state.isEnabled\n    });\n    onClick = lc.canUndo() ? ((function(_this) {\n      return function() {\n        return lc.clear();\n      };\n    })(this)) : function() {};\n    return div({\n      className: className,\n      onClick: onClick\n    }, _('Clear'));\n  }\n});\n\nmodule.exports = ClearButton;\n\n\n},{\"../core/localization\":13,\"../core/util\":19,\"./React-shim\":35,\"./createSetStateOnEventMixin\":40}],31:[function(require,module,exports){\nvar ColorGrid, ColorWell, PureRenderMixin, React, _, cancelAnimationFrame, classSet, getHSLAString, getHSLString, parseHSLAString, ref, requestAnimationFrame;\n\nReact = require('./React-shim');\n\nPureRenderMixin = require('react-addons-pure-render-mixin');\n\nref = require('../core/util'), classSet = ref.classSet, requestAnimationFrame = ref.requestAnimationFrame, cancelAnimationFrame = ref.cancelAnimationFrame;\n\n_ = require('../core/localization')._;\n\nparseHSLAString = function(s) {\n  var components, firstParen, insideParens, lastParen;\n  if (s === 'transparent') {\n    return {\n      hue: 0,\n      sat: 0,\n      light: 0,\n      alpha: 0\n    };\n  }\n  if ((s != null ? s.substring(0, 4) : void 0) !== 'hsla') {\n    return null;\n  }\n  firstParen = s.indexOf('(');\n  lastParen = s.indexOf(')');\n  insideParens = s.substring(firstParen + 1, lastParen - firstParen + 4);\n  components = (function() {\n    var j, len, ref1, results;\n    ref1 = insideParens.split(',');\n    results = [];\n    for (j = 0, len = ref1.length; j < len; j++) {\n      s = ref1[j];\n      results.push(s.trim());\n    }\n    return results;\n  })();\n  return {\n    hue: parseInt(components[0], 10),\n    sat: parseInt(components[1].substring(0, components[1].length - 1), 10),\n    light: parseInt(components[2].substring(0, components[2].length - 1), 10),\n    alpha: parseFloat(components[3])\n  };\n};\n\ngetHSLAString = function(arg) {\n  var alpha, hue, light, sat;\n  hue = arg.hue, sat = arg.sat, light = arg.light, alpha = arg.alpha;\n  return \"hsla(\" + hue + \", \" + sat + \"%, \" + light + \"%, \" + alpha + \")\";\n};\n\ngetHSLString = function(arg) {\n  var hue, light, sat;\n  hue = arg.hue, sat = arg.sat, light = arg.light;\n  return \"hsl(\" + hue + \", \" + sat + \"%, \" + light + \"%)\";\n};\n\nColorGrid = React.createFactory(React.createClass({\n  displayName: 'ColorGrid',\n  mixins: [PureRenderMixin],\n  render: function() {\n    var div;\n    div = React.DOM.div;\n    return div({}, this.props.rows.map((function(_this) {\n      return function(row, ix) {\n        return div({\n          className: 'color-row',\n          key: ix,\n          style: {\n            width: 20 * row.length\n          }\n        }, row.map(function(cellColor, ix2) {\n          var alpha, className, colorString, colorStringNoAlpha, hue, light, sat, update;\n          hue = cellColor.hue, sat = cellColor.sat, light = cellColor.light, alpha = cellColor.alpha;\n          colorString = getHSLAString(cellColor);\n          colorStringNoAlpha = \"hsl(\" + hue + \", \" + sat + \"%, \" + light + \"%)\";\n          className = classSet({\n            'color-cell': true,\n            'selected': _this.props.selectedColor === colorString\n          });\n          update = function(e) {\n            _this.props.onChange(cellColor, colorString);\n            e.stopPropagation();\n            return e.preventDefault();\n          };\n          return div({\n            className: className,\n            onTouchStart: update,\n            onTouchMove: update,\n            onClick: update,\n            style: {\n              backgroundColor: colorStringNoAlpha\n            },\n            key: ix2\n          });\n        }));\n      };\n    })(this)));\n  }\n}));\n\nColorWell = React.createClass({\n  displayName: 'ColorWell',\n  mixins: [PureRenderMixin],\n  getInitialState: function() {\n    var colorString, hsla;\n    colorString = this.props.lc.colors[this.props.colorName];\n    hsla = parseHSLAString(colorString);\n    if (hsla == null) {\n      hsla = {};\n    }\n    if (hsla.alpha == null) {\n      hsla.alpha = 1;\n    }\n    if (hsla.sat == null) {\n      hsla.sat = 100;\n    }\n    if (hsla.hue == null) {\n      hsla.hue = 0;\n    }\n    if (hsla.light == null) {\n      hsla.light = 50;\n    }\n    return {\n      colorString: colorString,\n      alpha: hsla.alpha,\n      sat: hsla.sat === 0 ? 100 : hsla.sat,\n      isPickerVisible: false,\n      hsla: hsla\n    };\n  },\n  componentDidMount: function() {\n    return this.unsubscribe = this.props.lc.on(this.props.colorName + \"ColorChange\", (function(_this) {\n      return function() {\n        var colorString;\n        colorString = _this.props.lc.colors[_this.props.colorName];\n        _this.setState({\n          colorString: colorString\n        });\n        return _this.setHSLAFromColorString(colorString);\n      };\n    })(this));\n  },\n  componentWillUnmount: function() {\n    return this.unsubscribe();\n  },\n  setHSLAFromColorString: function(c) {\n    var hsla;\n    hsla = parseHSLAString(c);\n    if (hsla) {\n      return this.setState({\n        hsla: hsla,\n        alpha: hsla.alpha,\n        sat: hsla.sat\n      });\n    } else {\n      return this.setState({\n        hsla: null,\n        alpha: 1,\n        sat: 100\n      });\n    }\n  },\n  closePicker: function() {\n    return this.setState({\n      isPickerVisible: false\n    });\n  },\n  togglePicker: function() {\n    var isPickerVisible, shouldResetSat;\n    isPickerVisible = !this.state.isPickerVisible;\n    shouldResetSat = isPickerVisible && this.state.sat === 0;\n    this.setHSLAFromColorString(this.state.colorString);\n    return this.setState({\n      isPickerVisible: isPickerVisible,\n      sat: shouldResetSat ? 100 : this.state.sat\n    });\n  },\n  setColor: function(c) {\n    this.setState({\n      colorString: c\n    });\n    this.setHSLAFromColorString(c);\n    return this.props.lc.setColor(this.props.colorName, c);\n  },\n  setAlpha: function(alpha) {\n    var hsla;\n    this.setState({\n      alpha: alpha\n    });\n    if (this.state.hsla) {\n      hsla = this.state.hsla;\n      hsla.alpha = alpha;\n      this.setState({\n        hsla: hsla\n      });\n      return this.setColor(getHSLAString(hsla));\n    }\n  },\n  setSat: function(sat) {\n    var hsla;\n    this.setState({\n      sat: sat\n    });\n    if (isNaN(sat)) {\n      throw \"SAT\";\n    }\n    if (this.state.hsla) {\n      hsla = this.state.hsla;\n      hsla.sat = sat;\n      this.setState({\n        hsla: hsla\n      });\n      return this.setColor(getHSLAString(hsla));\n    }\n  },\n  render: function() {\n    var br, div, label, ref1;\n    ref1 = React.DOM, div = ref1.div, label = ref1.label, br = ref1.br;\n    return div({\n      className: classSet({\n        'color-well': true,\n        'open': this.state.isPickerVisible\n      }),\n      onMouseLeave: this.closePicker,\n      style: {\n        float: 'left',\n        textAlign: 'center'\n      }\n    }, label({\n      float: 'left'\n    }, this.props.label), br({}), div({\n      className: classSet({\n        'color-well-color-container': true,\n        'selected': this.state.isPickerVisible\n      }),\n      style: {\n        backgroundColor: 'white'\n      },\n      onClick: this.togglePicker\n    }, div({\n      className: 'color-well-checker color-well-checker-top-left'\n    }), div({\n      className: 'color-well-checker color-well-checker-bottom-right',\n      style: {\n        left: '50%',\n        top: '50%'\n      }\n    }), div({\n      className: 'color-well-color',\n      style: {\n        backgroundColor: this.state.colorString\n      }\n    }, \" \")), this.renderPicker());\n  },\n  renderPicker: function() {\n    var div, hue, i, input, j, label, len, onSelectColor, ref1, ref2, renderColor, renderLabel, rows;\n    ref1 = React.DOM, div = ref1.div, label = ref1.label, input = ref1.input;\n    if (!this.state.isPickerVisible) {\n      return null;\n    }\n    renderLabel = (function(_this) {\n      return function(text) {\n        return div({\n          className: 'color-row label',\n          key: text,\n          style: {\n            lineHeight: '20px',\n            height: 16\n          }\n        }, text);\n      };\n    })(this);\n    renderColor = (function(_this) {\n      return function() {\n        var checkerboardURL;\n        checkerboardURL = _this.props.lc.opts.imageURLPrefix + \"/checkerboard-8x8.png\";\n        return div({\n          className: 'color-row',\n          key: \"color\",\n          style: {\n            position: 'relative',\n            backgroundImage: \"url(\" + checkerboardURL + \")\",\n            backgroundRepeat: 'repeat',\n            height: 24\n          }\n        }, div({\n          style: {\n            position: 'absolute',\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            backgroundColor: _this.state.colorString\n          }\n        }));\n      };\n    })(this);\n    rows = [];\n    rows.push((function() {\n      var j, results;\n      results = [];\n      for (i = j = 0; j <= 100; i = j += 10) {\n        results.push({\n          hue: 0,\n          sat: 0,\n          light: i,\n          alpha: this.state.alpha\n        });\n      }\n      return results;\n    }).call(this));\n    ref2 = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];\n    for (j = 0, len = ref2.length; j < len; j++) {\n      hue = ref2[j];\n      rows.push((function() {\n        var k, results;\n        results = [];\n        for (i = k = 10; k <= 90; i = k += 8) {\n          results.push({\n            hue: hue,\n            sat: this.state.sat,\n            light: i,\n            alpha: this.state.alpha\n          });\n        }\n        return results;\n      }).call(this));\n    }\n    onSelectColor = (function(_this) {\n      return function(hsla, s) {\n        return _this.setColor(s);\n      };\n    })(this);\n    return div({\n      className: 'color-picker-popup'\n    }, renderColor(), renderLabel(_(\"alpha\")), input({\n      type: 'range',\n      min: 0,\n      max: 1,\n      step: 0.01,\n      value: this.state.alpha,\n      onChange: (function(_this) {\n        return function(e) {\n          return _this.setAlpha(parseFloat(e.target.value));\n        };\n      })(this)\n    }), renderLabel(_(\"saturation\")), input({\n      type: 'range',\n      min: 0,\n      max: 100,\n      value: this.state.sat,\n      max: 100,\n      onChange: (function(_this) {\n        return function(e) {\n          return _this.setSat(parseInt(e.target.value, 10));\n        };\n      })(this)\n    }), ColorGrid({\n      rows: rows,\n      selectedColor: this.state.colorString,\n      onChange: onSelectColor\n    }));\n  }\n});\n\nmodule.exports = ColorWell;\n\n\n},{\"../core/localization\":13,\"../core/util\":19,\"./React-shim\":35,\"react-addons-pure-render-mixin\":2}],32:[function(require,module,exports){\n'use strict';\n\nvar React = require('../reactGUI/React-shim');\n\nvar _require = require('../reactGUI/ReactDOM-shim');\n\nvar findDOMNode = _require.findDOMNode;\n\nvar _require2 = require('../core/util');\n\nvar classSet = _require2.classSet;\n\nvar Picker = require('./Picker');\nvar Options = require('./Options');\nvar createToolButton = require('./createToolButton');\nvar LiterallyCanvasModel = require('../core/LiterallyCanvas');\nvar defaultOptions = require('../core/defaultOptions');\n\nrequire('../optionsStyles/font');\nrequire('../optionsStyles/stroke-width');\nrequire('../optionsStyles/line-options-and-stroke-width');\nrequire('../optionsStyles/polygon-and-stroke-width');\nrequire('../optionsStyles/null');\n\nvar CanvasContainer = React.createClass({\n  displayName: 'CanvasContainer',\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    // Avoid React trying to control this DOM\n    return false;\n  },\n  render: function render() {\n    return React.createElement('div', { key: 'literallycanvas', className: 'lc-drawing with-gui' });\n  }\n});\n\nvar LiterallyCanvas = React.createClass({\n  displayName: 'LiterallyCanvas',\n\n  getDefaultProps: function getDefaultProps() {\n    return defaultOptions;\n  },\n  bindToModel: function bindToModel() {\n    var canvasContainerEl = findDOMNode(this.canvas);\n    var opts = this.props;\n    this.lc.bindToElement(canvasContainerEl);\n\n    if (typeof this.lc.opts.onInit === 'function') {\n      this.lc.opts.onInit(this.lc);\n    }\n  },\n  componentWillMount: function componentWillMount() {\n    var _this = this;\n\n    if (this.lc) return;\n\n    if (this.props.lc) {\n      this.lc = this.props.lc;\n    } else {\n      this.lc = new LiterallyCanvasModel(this.props);\n    }\n\n    this.toolButtonComponents = this.lc.opts.tools.map(function (ToolClass) {\n      return createToolButton(new ToolClass(_this.lc));\n    });\n  },\n  componentDidMount: function componentDidMount() {\n    if (!this.lc.isBound) {\n      this.bindToModel();\n    }\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (this.lc) {\n      this.lc._teardown();\n    }\n  },\n  render: function render() {\n    var _this2 = this;\n\n    var lc = this.lc;\n    var toolButtonComponents = this.toolButtonComponents;\n    var props = this.props;\n    var _lc$opts = this.lc.opts;\n    var imageURLPrefix = _lc$opts.imageURLPrefix;\n    var toolbarPosition = _lc$opts.toolbarPosition;\n\n\n    var pickerProps = { lc: lc, toolButtonComponents: toolButtonComponents, imageURLPrefix: imageURLPrefix };\n    var topOrBottomClassName = classSet({\n      'toolbar-at-top': toolbarPosition === 'top',\n      'toolbar-at-bottom': toolbarPosition === 'bottom',\n      'toolbar-hidden': toolbarPosition === 'hidden'\n    });\n    return React.createElement(\n      'div',\n      { className: 'literally ' + topOrBottomClassName },\n      React.createElement(CanvasContainer, { ref: function ref(item) {\n          return _this2.canvas = item;\n        } }),\n      React.createElement(Picker, pickerProps),\n      React.createElement(Options, { lc: lc, imageURLPrefix: imageURLPrefix })\n    );\n  }\n});\n\nmodule.exports = LiterallyCanvas;\n\n},{\"../core/LiterallyCanvas\":5,\"../core/defaultOptions\":10,\"../core/util\":19,\"../optionsStyles/font\":23,\"../optionsStyles/line-options-and-stroke-width\":24,\"../optionsStyles/null\":25,\"../optionsStyles/polygon-and-stroke-width\":27,\"../optionsStyles/stroke-width\":29,\"../reactGUI/React-shim\":35,\"../reactGUI/ReactDOM-shim\":36,\"./Options\":33,\"./Picker\":34,\"./createToolButton\":41}],33:[function(require,module,exports){\nvar Options, React, createSetStateOnEventMixin, optionsStyles;\n\nReact = require('./React-shim');\n\ncreateSetStateOnEventMixin = require('./createSetStateOnEventMixin');\n\noptionsStyles = require('../optionsStyles/optionsStyles').optionsStyles;\n\nOptions = React.createClass({\n  displayName: 'Options',\n  getState: function() {\n    var ref;\n    return {\n      style: (ref = this.props.lc.tool) != null ? ref.optionsStyle : void 0,\n      tool: this.props.lc.tool\n    };\n  },\n  getInitialState: function() {\n    return this.getState();\n  },\n  mixins: [createSetStateOnEventMixin('toolChange')],\n  renderBody: function() {\n    var style;\n    style = \"\" + this.state.style;\n    return optionsStyles[style] && optionsStyles[style]({\n      lc: this.props.lc,\n      tool: this.state.tool,\n      imageURLPrefix: this.props.imageURLPrefix\n    });\n  },\n  render: function() {\n    var div;\n    div = React.DOM.div;\n    return div({\n      className: 'lc-options horz-toolbar'\n    }, this.renderBody());\n  }\n});\n\nmodule.exports = Options;\n\n\n},{\"../optionsStyles/optionsStyles\":26,\"./React-shim\":35,\"./createSetStateOnEventMixin\":40}],34:[function(require,module,exports){\nvar ClearButton, ColorPickers, ColorWell, Picker, React, UndoRedoButtons, ZoomButtons, _;\n\nReact = require('./React-shim');\n\nClearButton = React.createFactory(require('./ClearButton'));\n\nUndoRedoButtons = React.createFactory(require('./UndoRedoButtons'));\n\nZoomButtons = React.createFactory(require('./ZoomButtons'));\n\n_ = require('../core/localization')._;\n\nColorWell = React.createFactory(require('./ColorWell'));\n\nColorPickers = React.createFactory(React.createClass({\n  displayName: 'ColorPickers',\n  render: function() {\n    var div, lc;\n    lc = this.props.lc;\n    div = React.DOM.div;\n    return div({\n      className: 'lc-color-pickers'\n    }, ColorWell({\n      lc: lc,\n      colorName: 'primary',\n      label: _('stroke')\n    }), ColorWell({\n      lc: lc,\n      colorName: 'secondary',\n      label: _('fill')\n    }), ColorWell({\n      lc: lc,\n      colorName: 'background',\n      label: _('bg')\n    }));\n  }\n}));\n\nPicker = React.createClass({\n  displayName: 'Picker',\n  getInitialState: function() {\n    return {\n      selectedToolIndex: 0\n    };\n  },\n  renderBody: function() {\n    var div, imageURLPrefix, lc, ref, toolButtonComponents;\n    div = React.DOM.div;\n    ref = this.props, toolButtonComponents = ref.toolButtonComponents, lc = ref.lc, imageURLPrefix = ref.imageURLPrefix;\n    return div({\n      className: 'lc-picker-contents'\n    }, toolButtonComponents.map((function(_this) {\n      return function(component, ix) {\n        return component({\n          lc: lc,\n          imageURLPrefix: imageURLPrefix,\n          key: ix,\n          isSelected: ix === _this.state.selectedToolIndex,\n          onSelect: function(tool) {\n            lc.setTool(tool);\n            return _this.setState({\n              selectedToolIndex: ix\n            });\n          }\n        });\n      };\n    })(this)), toolButtonComponents.length % 2 !== 0 ? div({\n      className: 'toolbar-button thin-button disabled'\n    }) : void 0, div({\n      style: {\n        position: 'absolute',\n        bottom: 0,\n        left: 0,\n        right: 0\n      }\n    }, ColorPickers({\n      lc: this.props.lc\n    }), UndoRedoButtons({\n      lc: lc,\n      imageURLPrefix: imageURLPrefix\n    }), ZoomButtons({\n      lc: lc,\n      imageURLPrefix: imageURLPrefix\n    }), ClearButton({\n      lc: lc\n    })));\n  },\n  render: function() {\n    var div;\n    div = React.DOM.div;\n    return div({\n      className: 'lc-picker'\n    }, this.renderBody());\n  }\n});\n\nmodule.exports = Picker;\n\n\n},{\"../core/localization\":13,\"./ClearButton\":30,\"./ColorWell\":31,\"./React-shim\":35,\"./UndoRedoButtons\":38,\"./ZoomButtons\":39}],35:[function(require,module,exports){\nvar React, error;\n\ntry {\n  React = require('react');\n} catch (error) {\n  React = window.React;\n}\n\nif (React == null) {\n  throw \"Can't find React\";\n}\n\nmodule.exports = React;\n\n\n},{\"react\":\"react\"}],36:[function(require,module,exports){\nvar ReactDOM, error, error1;\n\ntry {\n  ReactDOM = require('react-dom');\n} catch (error) {\n  ReactDOM = window.ReactDOM;\n}\n\nif (ReactDOM == null) {\n  try {\n    ReactDOM = require('react');\n  } catch (error1) {\n    ReactDOM = window.React;\n  }\n}\n\nif (ReactDOM == null) {\n  throw \"Can't find ReactDOM\";\n}\n\nmodule.exports = ReactDOM;\n\n\n},{\"react\":\"react\",\"react-dom\":\"react-dom\"}],37:[function(require,module,exports){\nvar React, classSet, createSetStateOnEventMixin;\n\nReact = require('./React-shim');\n\ncreateSetStateOnEventMixin = require('../reactGUI/createSetStateOnEventMixin');\n\nclassSet = require('../core/util').classSet;\n\nmodule.exports = React.createClass({\n  displayName: 'StrokeWidthPicker',\n  getState: function(tool) {\n    if (tool == null) {\n      tool = this.props.tool;\n    }\n    return {\n      strokeWidth: tool.strokeWidth\n    };\n  },\n  getInitialState: function() {\n    return this.getState();\n  },\n  mixins: [createSetStateOnEventMixin('toolDidUpdateOptions')],\n  componentWillReceiveProps: function(props) {\n    return this.setState(this.getState(props.tool));\n  },\n  render: function() {\n    var circle, div, li, ref, strokeWidths, svg, ul;\n    ref = React.DOM, ul = ref.ul, li = ref.li, svg = ref.svg, circle = ref.circle, div = ref.div;\n    strokeWidths = this.props.lc.opts.strokeWidths;\n    return div({}, strokeWidths.map((function(_this) {\n      return function(strokeWidth, ix) {\n        var buttonClassName, buttonSize;\n        buttonClassName = classSet({\n          'square-toolbar-button': true,\n          'selected': strokeWidth === _this.state.strokeWidth\n        });\n        buttonSize = 28;\n        return div({\n          key: strokeWidth\n        }, div({\n          className: buttonClassName,\n          onClick: function() {\n            return _this.props.lc.trigger('setStrokeWidth', strokeWidth);\n          }\n        }, svg({\n          width: buttonSize - 2,\n          height: buttonSize - 2,\n          viewPort: \"0 0 \" + strokeWidth + \" \" + strokeWidth,\n          version: \"1.1\",\n          xmlns: \"http://www.w3.org/2000/svg\"\n        }, circle({\n          cx: Math.ceil(buttonSize / 2 - 1),\n          cy: Math.ceil(buttonSize / 2 - 1),\n          r: strokeWidth / 2\n        }))));\n      };\n    })(this)));\n  }\n});\n\n\n},{\"../core/util\":19,\"../reactGUI/createSetStateOnEventMixin\":40,\"./React-shim\":35}],38:[function(require,module,exports){\nvar React, RedoButton, UndoButton, UndoRedoButtons, classSet, createSetStateOnEventMixin, createUndoRedoButtonComponent;\n\nReact = require('./React-shim');\n\ncreateSetStateOnEventMixin = require('./createSetStateOnEventMixin');\n\nclassSet = require('../core/util').classSet;\n\ncreateUndoRedoButtonComponent = function(undoOrRedo) {\n  return React.createClass({\n    displayName: undoOrRedo === 'undo' ? 'UndoButton' : 'RedoButton',\n    getState: function() {\n      return {\n        isEnabled: (function() {\n          switch (false) {\n            case undoOrRedo !== 'undo':\n              return this.props.lc.canUndo();\n            case undoOrRedo !== 'redo':\n              return this.props.lc.canRedo();\n          }\n        }).call(this)\n      };\n    },\n    getInitialState: function() {\n      return this.getState();\n    },\n    mixins: [createSetStateOnEventMixin('drawingChange')],\n    render: function() {\n      var className, div, imageURLPrefix, img, lc, onClick, ref, ref1, src, style, title;\n      ref = React.DOM, div = ref.div, img = ref.img;\n      ref1 = this.props, lc = ref1.lc, imageURLPrefix = ref1.imageURLPrefix;\n      title = undoOrRedo === 'undo' ? 'Undo' : 'Redo';\n      className = (\"lc-\" + undoOrRedo + \" \") + classSet({\n        'toolbar-button': true,\n        'thin-button': true,\n        'disabled': !this.state.isEnabled\n      });\n      onClick = (function() {\n        switch (false) {\n          case !!this.state.isEnabled:\n            return function() {};\n          case undoOrRedo !== 'undo':\n            return function() {\n              return lc.undo();\n            };\n          case undoOrRedo !== 'redo':\n            return function() {\n              return lc.redo();\n            };\n        }\n      }).call(this);\n      src = imageURLPrefix + \"/\" + undoOrRedo + \".png\";\n      style = {\n        backgroundImage: \"url(\" + src + \")\"\n      };\n      return div({\n        className: className,\n        onClick: onClick,\n        title: title,\n        style: style\n      });\n    }\n  });\n};\n\nUndoButton = React.createFactory(createUndoRedoButtonComponent('undo'));\n\nRedoButton = React.createFactory(createUndoRedoButtonComponent('redo'));\n\nUndoRedoButtons = React.createClass({\n  displayName: 'UndoRedoButtons',\n  render: function() {\n    var div;\n    div = React.DOM.div;\n    return div({\n      className: 'lc-undo-redo'\n    }, UndoButton(this.props), RedoButton(this.props));\n  }\n});\n\nmodule.exports = UndoRedoButtons;\n\n\n},{\"../core/util\":19,\"./React-shim\":35,\"./createSetStateOnEventMixin\":40}],39:[function(require,module,exports){\nvar React, ZoomButtons, ZoomInButton, ZoomOutButton, classSet, createSetStateOnEventMixin, createZoomButtonComponent;\n\nReact = require('./React-shim');\n\ncreateSetStateOnEventMixin = require('./createSetStateOnEventMixin');\n\nclassSet = require('../core/util').classSet;\n\ncreateZoomButtonComponent = function(inOrOut) {\n  return React.createClass({\n    displayName: inOrOut === 'in' ? 'ZoomInButton' : 'ZoomOutButton',\n    getState: function() {\n      return {\n        isEnabled: (function() {\n          switch (false) {\n            case inOrOut !== 'in':\n              return this.props.lc.scale < this.props.lc.config.zoomMax;\n            case inOrOut !== 'out':\n              return this.props.lc.scale > this.props.lc.config.zoomMin;\n          }\n        }).call(this)\n      };\n    },\n    getInitialState: function() {\n      return this.getState();\n    },\n    mixins: [createSetStateOnEventMixin('zoom')],\n    render: function() {\n      var className, div, imageURLPrefix, img, lc, onClick, ref, ref1, src, style, title;\n      ref = React.DOM, div = ref.div, img = ref.img;\n      ref1 = this.props, lc = ref1.lc, imageURLPrefix = ref1.imageURLPrefix;\n      title = inOrOut === 'in' ? 'Zoom in' : 'Zoom out';\n      className = (\"lc-zoom-\" + inOrOut + \" \") + classSet({\n        'toolbar-button': true,\n        'thin-button': true,\n        'disabled': !this.state.isEnabled\n      });\n      onClick = (function() {\n        switch (false) {\n          case !!this.state.isEnabled:\n            return function() {};\n          case inOrOut !== 'in':\n            return function() {\n              return lc.zoom(lc.config.zoomStep);\n            };\n          case inOrOut !== 'out':\n            return function() {\n              return lc.zoom(-lc.config.zoomStep);\n            };\n        }\n      }).call(this);\n      src = imageURLPrefix + \"/zoom-\" + inOrOut + \".png\";\n      style = {\n        backgroundImage: \"url(\" + src + \")\"\n      };\n      return div({\n        className: className,\n        onClick: onClick,\n        title: title,\n        style: style\n      });\n    }\n  });\n};\n\nZoomOutButton = React.createFactory(createZoomButtonComponent('out'));\n\nZoomInButton = React.createFactory(createZoomButtonComponent('in'));\n\nZoomButtons = React.createClass({\n  displayName: 'ZoomButtons',\n  render: function() {\n    var div;\n    div = React.DOM.div;\n    return div({\n      className: 'lc-zoom'\n    }, ZoomOutButton(this.props), ZoomInButton(this.props));\n  }\n});\n\nmodule.exports = ZoomButtons;\n\n\n},{\"../core/util\":19,\"./React-shim\":35,\"./createSetStateOnEventMixin\":40}],40:[function(require,module,exports){\nvar React, createSetStateOnEventMixin;\n\nReact = require('./React-shim');\n\nmodule.exports = createSetStateOnEventMixin = function(eventName) {\n  return {\n    componentDidMount: function() {\n      return this.unsubscribe = this.props.lc.on(eventName, (function(_this) {\n        return function() {\n          return _this.setState(_this.getState());\n        };\n      })(this));\n    },\n    componentWillUnmount: function() {\n      return this.unsubscribe();\n    }\n  };\n};\n\n\n},{\"./React-shim\":35}],41:[function(require,module,exports){\nvar React, _, classSet, createToolButton;\n\nReact = require('./React-shim');\n\nclassSet = require('../core/util').classSet;\n\n_ = require('../core/localization')._;\n\ncreateToolButton = function(tool) {\n  var displayName, imageName;\n  displayName = tool.name;\n  imageName = tool.iconName;\n  return React.createFactory(React.createClass({\n    displayName: displayName,\n    getDefaultProps: function() {\n      return {\n        isSelected: false,\n        lc: null\n      };\n    },\n    componentWillMount: function() {\n      if (this.props.isSelected) {\n        return this.props.lc.setTool(tool);\n      }\n    },\n    render: function() {\n      var className, div, imageURLPrefix, img, isSelected, onSelect, ref, ref1, src;\n      ref = React.DOM, div = ref.div, img = ref.img;\n      ref1 = this.props, imageURLPrefix = ref1.imageURLPrefix, isSelected = ref1.isSelected, onSelect = ref1.onSelect;\n      className = classSet({\n        'lc-pick-tool': true,\n        'toolbar-button': true,\n        'thin-button': true,\n        'selected': isSelected\n      });\n      src = imageURLPrefix + \"/\" + imageName + \".png\";\n      return div({\n        className: className,\n        style: {\n          'backgroundImage': \"url(\" + src + \")\"\n        },\n        onClick: (function() {\n          return onSelect(tool);\n        }),\n        title: _(displayName)\n      });\n    }\n  }));\n};\n\nmodule.exports = createToolButton;\n\n\n},{\"../core/localization\":13,\"../core/util\":19,\"./React-shim\":35}],42:[function(require,module,exports){\n'use strict';\n\nvar React = require('./React-shim');\nvar ReactDOM = require('./ReactDOM-shim');\nvar LiterallyCanvasModel = require('../core/LiterallyCanvas');\nvar LiterallyCanvasReactComponent = require('./LiterallyCanvas');\n\nfunction init(el, opts) {\n  var originalClassName = el.className;\n  var lc = new LiterallyCanvasModel(opts);\n  ReactDOM.render(React.createElement(LiterallyCanvasReactComponent, { lc: lc }), el);\n  lc.teardown = function () {\n    lc._teardown();\n    for (var i = 0; i < el.children.length; i++) {\n      el.removeChild(el.children[i]);\n    }\n    el.className = originalClassName;\n  };\n  return lc;\n}\n\nmodule.exports = init;\n\n},{\"../core/LiterallyCanvas\":5,\"./LiterallyCanvas\":32,\"./React-shim\":35,\"./ReactDOM-shim\":36}],43:[function(require,module,exports){\nvar Ellipse, ToolWithStroke, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nToolWithStroke = require('./base').ToolWithStroke;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Ellipse = (function(superClass) {\n  extend(Ellipse, superClass);\n\n  function Ellipse() {\n    return Ellipse.__super__.constructor.apply(this, arguments);\n  }\n\n  Ellipse.prototype.name = 'Ellipse';\n\n  Ellipse.prototype.iconName = 'ellipse';\n\n  Ellipse.prototype.begin = function(x, y, lc) {\n    return this.currentShape = createShape('Ellipse', {\n      x: x,\n      y: y,\n      strokeWidth: this.strokeWidth,\n      strokeColor: lc.getColor('primary'),\n      fillColor: lc.getColor('secondary')\n    });\n  };\n\n  Ellipse.prototype[\"continue\"] = function(x, y, lc) {\n    this.currentShape.width = x - this.currentShape.x;\n    this.currentShape.height = y - this.currentShape.y;\n    return lc.drawShapeInProgress(this.currentShape);\n  };\n\n  Ellipse.prototype.end = function(x, y, lc) {\n    return lc.saveShape(this.currentShape);\n  };\n\n  return Ellipse;\n\n})(ToolWithStroke);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],44:[function(require,module,exports){\nvar Eraser, Pencil, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nPencil = require('./Pencil');\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Eraser = (function(superClass) {\n  extend(Eraser, superClass);\n\n  function Eraser() {\n    return Eraser.__super__.constructor.apply(this, arguments);\n  }\n\n  Eraser.prototype.name = 'Eraser';\n\n  Eraser.prototype.iconName = 'eraser';\n\n  Eraser.prototype.makePoint = function(x, y, lc) {\n    return createShape('Point', {\n      x: x,\n      y: y,\n      size: this.strokeWidth,\n      color: '#000'\n    });\n  };\n\n  Eraser.prototype.makeShape = function() {\n    return createShape('ErasedLinePath');\n  };\n\n  return Eraser;\n\n})(Pencil);\n\n\n},{\"../core/shapes\":17,\"./Pencil\":48}],45:[function(require,module,exports){\nvar Eyedropper, Tool, getPixel,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nTool = require('./base').Tool;\n\ngetPixel = function(ctx, arg) {\n  var pixel, x, y;\n  x = arg.x, y = arg.y;\n  pixel = ctx.getImageData(x, y, 1, 1).data;\n  if (pixel[3]) {\n    return \"rgb(\" + pixel[0] + \", \" + pixel[1] + \", \" + pixel[2] + \")\";\n  } else {\n    return null;\n  }\n};\n\nmodule.exports = Eyedropper = (function(superClass) {\n  extend(Eyedropper, superClass);\n\n  Eyedropper.prototype.name = 'Eyedropper';\n\n  Eyedropper.prototype.iconName = 'eyedropper';\n\n  Eyedropper.prototype.optionsStyle = 'stroke-or-fill';\n\n  function Eyedropper(lc) {\n    Eyedropper.__super__.constructor.call(this, lc);\n    this.strokeOrFill = 'stroke';\n  }\n\n  Eyedropper.prototype.readColor = function(x, y, lc) {\n    var canvas, color, newColor, offset;\n    offset = lc.getDefaultImageRect();\n    canvas = lc.getImage();\n    newColor = getPixel(canvas.getContext('2d'), {\n      x: x - offset.x,\n      y: y - offset.y\n    });\n    color = newColor || lc.getColor('background');\n    if (this.strokeOrFill === 'stroke') {\n      return lc.setColor('primary', newColor);\n    } else {\n      return lc.setColor('secondary', newColor);\n    }\n  };\n\n  Eyedropper.prototype.begin = function(x, y, lc) {\n    return this.readColor(x, y, lc);\n  };\n\n  Eyedropper.prototype[\"continue\"] = function(x, y, lc) {\n    return this.readColor(x, y, lc);\n  };\n\n  return Eyedropper;\n\n})(Tool);\n\n\n},{\"./base\":53}],46:[function(require,module,exports){\nvar Line, ToolWithStroke, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nToolWithStroke = require('./base').ToolWithStroke;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Line = (function(superClass) {\n  extend(Line, superClass);\n\n  function Line() {\n    return Line.__super__.constructor.apply(this, arguments);\n  }\n\n  Line.prototype.name = 'Line';\n\n  Line.prototype.iconName = 'line';\n\n  Line.prototype.optionsStyle = 'line-options-and-stroke-width';\n\n  Line.prototype.begin = function(x, y, lc) {\n    return this.currentShape = createShape('Line', {\n      x1: x,\n      y1: y,\n      x2: x,\n      y2: y,\n      strokeWidth: this.strokeWidth,\n      dash: (function() {\n        switch (false) {\n          case !this.isDashed:\n            return [this.strokeWidth * 2, this.strokeWidth * 4];\n          default:\n            return null;\n        }\n      }).call(this),\n      endCapShapes: this.hasEndArrow ? [null, 'arrow'] : null,\n      color: lc.getColor('primary')\n    });\n  };\n\n  Line.prototype[\"continue\"] = function(x, y, lc) {\n    this.currentShape.x2 = x;\n    this.currentShape.y2 = y;\n    return lc.drawShapeInProgress(this.currentShape);\n  };\n\n  Line.prototype.end = function(x, y, lc) {\n    return lc.saveShape(this.currentShape);\n  };\n\n  return Line;\n\n})(ToolWithStroke);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],47:[function(require,module,exports){\nvar Pan, Tool, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nTool = require('./base').Tool;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Pan = (function(superClass) {\n  extend(Pan, superClass);\n\n  function Pan() {\n    return Pan.__super__.constructor.apply(this, arguments);\n  }\n\n  Pan.prototype.name = 'Pan';\n\n  Pan.prototype.iconName = 'pan';\n\n  Pan.prototype.usesSimpleAPI = false;\n\n  Pan.prototype.didBecomeActive = function(lc) {\n    var unsubscribeFuncs;\n    unsubscribeFuncs = [];\n    this.unsubscribe = (function(_this) {\n      return function() {\n        var func, i, len, results;\n        results = [];\n        for (i = 0, len = unsubscribeFuncs.length; i < len; i++) {\n          func = unsubscribeFuncs[i];\n          results.push(func());\n        }\n        return results;\n      };\n    })(this);\n    unsubscribeFuncs.push(lc.on('lc-pointerdown', (function(_this) {\n      return function(arg) {\n        var rawX, rawY;\n        rawX = arg.rawX, rawY = arg.rawY;\n        _this.oldPosition = lc.position;\n        return _this.pointerStart = {\n          x: rawX,\n          y: rawY\n        };\n      };\n    })(this)));\n    return unsubscribeFuncs.push(lc.on('lc-pointerdrag', (function(_this) {\n      return function(arg) {\n        var dp, rawX, rawY;\n        rawX = arg.rawX, rawY = arg.rawY;\n        dp = {\n          x: (rawX - _this.pointerStart.x) * lc.backingScale,\n          y: (rawY - _this.pointerStart.y) * lc.backingScale\n        };\n        return lc.setPan(_this.oldPosition.x + dp.x, _this.oldPosition.y + dp.y);\n      };\n    })(this)));\n  };\n\n  Pan.prototype.willBecomeInactive = function(lc) {\n    return this.unsubscribe();\n  };\n\n  return Pan;\n\n})(Tool);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],48:[function(require,module,exports){\nvar Pencil, ToolWithStroke, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nToolWithStroke = require('./base').ToolWithStroke;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Pencil = (function(superClass) {\n  extend(Pencil, superClass);\n\n  function Pencil() {\n    return Pencil.__super__.constructor.apply(this, arguments);\n  }\n\n  Pencil.prototype.name = 'Pencil';\n\n  Pencil.prototype.iconName = 'pencil';\n\n  Pencil.prototype.eventTimeThreshold = 10;\n\n  Pencil.prototype.begin = function(x, y, lc) {\n    this.color = lc.getColor('primary');\n    this.currentShape = this.makeShape();\n    this.currentShape.addPoint(this.makePoint(x, y, lc));\n    return this.lastEventTime = Date.now();\n  };\n\n  Pencil.prototype[\"continue\"] = function(x, y, lc) {\n    var timeDiff;\n    timeDiff = Date.now() - this.lastEventTime;\n    if (timeDiff > this.eventTimeThreshold) {\n      this.lastEventTime += timeDiff;\n      this.currentShape.addPoint(this.makePoint(x, y, lc));\n      return lc.drawShapeInProgress(this.currentShape);\n    }\n  };\n\n  Pencil.prototype.end = function(x, y, lc) {\n    lc.saveShape(this.currentShape);\n    return this.currentShape = void 0;\n  };\n\n  Pencil.prototype.makePoint = function(x, y, lc) {\n    return createShape('Point', {\n      x: x,\n      y: y,\n      size: this.strokeWidth,\n      color: this.color\n    });\n  };\n\n  Pencil.prototype.makeShape = function() {\n    return createShape('LinePath');\n  };\n\n  return Pencil;\n\n})(ToolWithStroke);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],49:[function(require,module,exports){\nvar Polygon, ToolWithStroke, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nToolWithStroke = require('./base').ToolWithStroke;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Polygon = (function(superClass) {\n  extend(Polygon, superClass);\n\n  function Polygon() {\n    return Polygon.__super__.constructor.apply(this, arguments);\n  }\n\n  Polygon.prototype.name = 'Polygon';\n\n  Polygon.prototype.iconName = 'polygon';\n\n  Polygon.prototype.usesSimpleAPI = false;\n\n  Polygon.prototype.didBecomeActive = function(lc) {\n    var onDown, onMove, onUp, polygonCancel, polygonFinishClosed, polygonFinishOpen, polygonUnsubscribeFuncs;\n    Polygon.__super__.didBecomeActive.call(this, lc);\n    polygonUnsubscribeFuncs = [];\n    this.polygonUnsubscribe = (function(_this) {\n      return function() {\n        var func, i, len, results;\n        results = [];\n        for (i = 0, len = polygonUnsubscribeFuncs.length; i < len; i++) {\n          func = polygonUnsubscribeFuncs[i];\n          results.push(func());\n        }\n        return results;\n      };\n    })(this);\n    this.points = null;\n    this.maybePoint = null;\n    onUp = (function(_this) {\n      return function() {\n        if (_this._getWillFinish()) {\n          return _this._close(lc);\n        }\n        lc.trigger('lc-polygon-started');\n        if (_this.points) {\n          _this.points.push(_this.maybePoint);\n        } else {\n          _this.points = [_this.maybePoint];\n        }\n        _this.maybePoint = {\n          x: _this.maybePoint.x,\n          y: _this.maybePoint.y\n        };\n        lc.setShapesInProgress(_this._getShapes(lc));\n        return lc.repaintLayer('main');\n      };\n    })(this);\n    onMove = (function(_this) {\n      return function(arg) {\n        var x, y;\n        x = arg.x, y = arg.y;\n        if (_this.maybePoint) {\n          _this.maybePoint.x = x;\n          _this.maybePoint.y = y;\n          lc.setShapesInProgress(_this._getShapes(lc));\n          return lc.repaintLayer('main');\n        }\n      };\n    })(this);\n    onDown = (function(_this) {\n      return function(arg) {\n        var x, y;\n        x = arg.x, y = arg.y;\n        _this.maybePoint = {\n          x: x,\n          y: y\n        };\n        lc.setShapesInProgress(_this._getShapes(lc));\n        return lc.repaintLayer('main');\n      };\n    })(this);\n    polygonFinishOpen = (function(_this) {\n      return function() {\n        _this.maybePoint = {\n          x: Infinity,\n          y: Infinity\n        };\n        return _this._close(lc);\n      };\n    })(this);\n    polygonFinishClosed = (function(_this) {\n      return function() {\n        _this.maybePoint = _this.points[0];\n        return _this._close(lc);\n      };\n    })(this);\n    polygonCancel = (function(_this) {\n      return function() {\n        return _this._cancel(lc);\n      };\n    })(this);\n    polygonUnsubscribeFuncs.push(lc.on('drawingChange', (function(_this) {\n      return function() {\n        return _this._cancel(lc);\n      };\n    })(this)));\n    polygonUnsubscribeFuncs.push(lc.on('lc-pointerdown', onDown));\n    polygonUnsubscribeFuncs.push(lc.on('lc-pointerdrag', onMove));\n    polygonUnsubscribeFuncs.push(lc.on('lc-pointermove', onMove));\n    polygonUnsubscribeFuncs.push(lc.on('lc-pointerup', onUp));\n    polygonUnsubscribeFuncs.push(lc.on('lc-polygon-finishopen', polygonFinishOpen));\n    polygonUnsubscribeFuncs.push(lc.on('lc-polygon-finishclosed', polygonFinishClosed));\n    return polygonUnsubscribeFuncs.push(lc.on('lc-polygon-cancel', polygonCancel));\n  };\n\n  Polygon.prototype.willBecomeInactive = function(lc) {\n    Polygon.__super__.willBecomeInactive.call(this, lc);\n    if (this.points || this.maybePoint) {\n      this._cancel(lc);\n    }\n    return this.polygonUnsubscribe();\n  };\n\n  Polygon.prototype._getArePointsClose = function(a, b) {\n    return (Math.abs(a.x - b.x) + Math.abs(a.y - b.y)) < 10;\n  };\n\n  Polygon.prototype._getWillClose = function() {\n    if (!(this.points && this.points.length > 1)) {\n      return false;\n    }\n    if (!this.maybePoint) {\n      return false;\n    }\n    return this._getArePointsClose(this.points[0], this.maybePoint);\n  };\n\n  Polygon.prototype._getWillFinish = function() {\n    if (!(this.points && this.points.length > 1)) {\n      return false;\n    }\n    if (!this.maybePoint) {\n      return false;\n    }\n    return this._getArePointsClose(this.points[0], this.maybePoint) || this._getArePointsClose(this.points[this.points.length - 1], this.maybePoint);\n  };\n\n  Polygon.prototype._cancel = function(lc) {\n    lc.trigger('lc-polygon-stopped');\n    this.maybePoint = null;\n    this.points = null;\n    lc.setShapesInProgress([]);\n    return lc.repaintLayer('main');\n  };\n\n  Polygon.prototype._close = function(lc) {\n    lc.trigger('lc-polygon-stopped');\n    lc.setShapesInProgress([]);\n    if (this.points.length > 2) {\n      lc.saveShape(this._getShape(lc, false));\n    }\n    this.maybePoint = null;\n    return this.points = null;\n  };\n\n  Polygon.prototype._getShapes = function(lc, isInProgress) {\n    var shape;\n    if (isInProgress == null) {\n      isInProgress = true;\n    }\n    shape = this._getShape(lc, isInProgress);\n    if (shape) {\n      return [shape];\n    } else {\n      return [];\n    }\n  };\n\n  Polygon.prototype._getShape = function(lc, isInProgress) {\n    var points;\n    if (isInProgress == null) {\n      isInProgress = true;\n    }\n    points = [];\n    if (this.points) {\n      points = points.concat(this.points);\n    }\n    if ((!isInProgress) && points.length < 3) {\n      return null;\n    }\n    if (isInProgress && this.maybePoint) {\n      points.push(this.maybePoint);\n    }\n    if (points.length > 1) {\n      return createShape('Polygon', {\n        isClosed: this._getWillClose(),\n        strokeColor: lc.getColor('primary'),\n        fillColor: lc.getColor('secondary'),\n        strokeWidth: this.strokeWidth,\n        points: points.map(function(xy) {\n          return createShape('Point', xy);\n        })\n      });\n    } else {\n      return null;\n    }\n  };\n\n  Polygon.prototype.optionsStyle = 'polygon-and-stroke-width';\n\n  return Polygon;\n\n})(ToolWithStroke);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],50:[function(require,module,exports){\nvar Rectangle, ToolWithStroke, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nToolWithStroke = require('./base').ToolWithStroke;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = Rectangle = (function(superClass) {\n  extend(Rectangle, superClass);\n\n  function Rectangle() {\n    return Rectangle.__super__.constructor.apply(this, arguments);\n  }\n\n  Rectangle.prototype.name = 'Rectangle';\n\n  Rectangle.prototype.iconName = 'rectangle';\n\n  Rectangle.prototype.begin = function(x, y, lc) {\n    return this.currentShape = createShape('Rectangle', {\n      x: x,\n      y: y,\n      strokeWidth: this.strokeWidth,\n      strokeColor: lc.getColor('primary'),\n      fillColor: lc.getColor('secondary')\n    });\n  };\n\n  Rectangle.prototype[\"continue\"] = function(x, y, lc) {\n    this.currentShape.width = x - this.currentShape.x;\n    this.currentShape.height = y - this.currentShape.y;\n    return lc.drawShapeInProgress(this.currentShape);\n  };\n\n  Rectangle.prototype.end = function(x, y, lc) {\n    return lc.saveShape(this.currentShape);\n  };\n\n  return Rectangle;\n\n})(ToolWithStroke);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],51:[function(require,module,exports){\nvar SelectShape, Tool, createShape,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nTool = require('./base').Tool;\n\ncreateShape = require('../core/shapes').createShape;\n\nmodule.exports = SelectShape = (function(superClass) {\n  extend(SelectShape, superClass);\n\n  SelectShape.prototype.name = 'SelectShape';\n\n  SelectShape.prototype.usesSimpleAPI = false;\n\n  function SelectShape(lc) {\n    this.selectCanvas = document.createElement('canvas');\n    this.selectCanvas.style['background-color'] = 'transparent';\n    this.selectCtx = this.selectCanvas.getContext('2d');\n  }\n\n  SelectShape.prototype.didBecomeActive = function(lc) {\n    var onDown, onDrag, onUp, selectShapeUnsubscribeFuncs;\n    selectShapeUnsubscribeFuncs = [];\n    this._selectShapeUnsubscribe = (function(_this) {\n      return function() {\n        var func, j, len, results;\n        results = [];\n        for (j = 0, len = selectShapeUnsubscribeFuncs.length; j < len; j++) {\n          func = selectShapeUnsubscribeFuncs[j];\n          results.push(func());\n        }\n        return results;\n      };\n    })(this);\n    onDown = (function(_this) {\n      return function(arg) {\n        var br, shapeIndex, x, y;\n        x = arg.x, y = arg.y;\n        _this.didDrag = false;\n        shapeIndex = _this._getPixel(x, y, lc, _this.selectCtx);\n        _this.selectedShape = lc.shapes[shapeIndex];\n        if (_this.selectedShape != null) {\n          lc.trigger('shapeSelected', {\n            selectedShape: _this.selectedShape\n          });\n          lc.setShapesInProgress([\n            _this.selectedShape, createShape('SelectionBox', {\n              shape: _this.selectedShape,\n              handleSize: 0\n            })\n          ]);\n          lc.repaintLayer('main');\n          br = _this.selectedShape.getBoundingRect();\n          return _this.dragOffset = {\n            x: x - br.x,\n            y: y - br.y\n          };\n        }\n      };\n    })(this);\n    onDrag = (function(_this) {\n      return function(arg) {\n        var x, y;\n        x = arg.x, y = arg.y;\n        if (_this.selectedShape != null) {\n          _this.didDrag = true;\n          _this.selectedShape.setUpperLeft({\n            x: x - _this.dragOffset.x,\n            y: y - _this.dragOffset.y\n          });\n          lc.setShapesInProgress([\n            _this.selectedShape, createShape('SelectionBox', {\n              shape: _this.selectedShape,\n              handleSize: 0\n            })\n          ]);\n          return lc.repaintLayer('main');\n        }\n      };\n    })(this);\n    onUp = (function(_this) {\n      return function(arg) {\n        var x, y;\n        x = arg.x, y = arg.y;\n        if (_this.didDrag) {\n          _this.didDrag = false;\n          lc.trigger('shapeMoved', {\n            shape: _this.selectedShape\n          });\n          lc.trigger('drawingChange', {});\n          lc.repaintLayer('main');\n          return _this._drawSelectCanvas(lc);\n        }\n      };\n    })(this);\n    selectShapeUnsubscribeFuncs.push(lc.on('lc-pointerdown', onDown));\n    selectShapeUnsubscribeFuncs.push(lc.on('lc-pointerdrag', onDrag));\n    selectShapeUnsubscribeFuncs.push(lc.on('lc-pointerup', onUp));\n    return this._drawSelectCanvas(lc);\n  };\n\n  SelectShape.prototype.willBecomeInactive = function(lc) {\n    this._selectShapeUnsubscribe();\n    return lc.setShapesInProgress([]);\n  };\n\n  SelectShape.prototype._drawSelectCanvas = function(lc) {\n    var shapes;\n    this.selectCanvas.width = lc.canvas.width;\n    this.selectCanvas.height = lc.canvas.height;\n    this.selectCtx.clearRect(0, 0, this.selectCanvas.width, this.selectCanvas.height);\n    shapes = lc.shapes.map((function(_this) {\n      return function(shape, index) {\n        return createShape('SelectionBox', {\n          shape: shape,\n          handleSize: 0,\n          backgroundColor: \"#\" + (_this._intToHex(index))\n        });\n      };\n    })(this));\n    return lc.draw(shapes, this.selectCtx);\n  };\n\n  SelectShape.prototype._intToHex = function(i) {\n    return (\"000000\" + (i.toString(16))).slice(-6);\n  };\n\n  SelectShape.prototype._getPixel = function(x, y, lc, ctx) {\n    var p, pixel;\n    p = lc.drawingCoordsToClientCoords(x, y);\n    pixel = ctx.getImageData(p.x, p.y, 1, 1).data;\n    if (pixel[3]) {\n      return parseInt(this._rgbToHex(pixel[0], pixel[1], pixel[2]), 16);\n    } else {\n      return null;\n    }\n  };\n\n  SelectShape.prototype._componentToHex = function(c) {\n    var hex;\n    hex = c.toString(16);\n    return (\"0\" + hex).slice(-2);\n  };\n\n  SelectShape.prototype._rgbToHex = function(r, g, b) {\n    return \"\" + (this._componentToHex(r)) + (this._componentToHex(g)) + (this._componentToHex(b));\n  };\n\n  return SelectShape;\n\n})(Tool);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],52:[function(require,module,exports){\nvar Text, Tool, createShape, getIsPointInBox,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nTool = require('./base').Tool;\n\ncreateShape = require('../core/shapes').createShape;\n\ngetIsPointInBox = function(point, box) {\n  if (point.x < box.x) {\n    return false;\n  }\n  if (point.y < box.y) {\n    return false;\n  }\n  if (point.x > box.x + box.width) {\n    return false;\n  }\n  if (point.y > box.y + box.height) {\n    return false;\n  }\n  return true;\n};\n\nmodule.exports = Text = (function(superClass) {\n  extend(Text, superClass);\n\n  Text.prototype.name = 'Text';\n\n  Text.prototype.iconName = 'text';\n\n  function Text() {\n    this.text = '';\n    this.font = 'bold 18px sans-serif';\n    this.currentShape = null;\n    this.currentShapeState = null;\n    this.initialShapeBoundingRect = null;\n    this.dragAction = null;\n    this.didDrag = false;\n  }\n\n  Text.prototype.didBecomeActive = function(lc) {\n    var switchAway, unsubscribeFuncs, updateInputEl;\n    unsubscribeFuncs = [];\n    this.unsubscribe = (function(_this) {\n      return function() {\n        var func, i, len, results;\n        results = [];\n        for (i = 0, len = unsubscribeFuncs.length; i < len; i++) {\n          func = unsubscribeFuncs[i];\n          results.push(func());\n        }\n        return results;\n      };\n    })(this);\n    switchAway = (function(_this) {\n      return function() {\n        _this._ensureNotEditing(lc);\n        _this._clearCurrentShape(lc);\n        return lc.repaintLayer('main');\n      };\n    })(this);\n    updateInputEl = (function(_this) {\n      return function() {\n        return _this._updateInputEl(lc);\n      };\n    })(this);\n    unsubscribeFuncs.push(lc.on('drawingChange', switchAway));\n    unsubscribeFuncs.push(lc.on('zoom', updateInputEl));\n    unsubscribeFuncs.push(lc.on('imageSizeChange', updateInputEl));\n    unsubscribeFuncs.push(lc.on('snapshotLoad', (function(_this) {\n      return function() {\n        _this._clearCurrentShape(lc);\n        return lc.repaintLayer('main');\n      };\n    })(this)));\n    unsubscribeFuncs.push(lc.on('primaryColorChange', (function(_this) {\n      return function(newColor) {\n        if (!_this.currentShape) {\n          return;\n        }\n        _this.currentShape.color = newColor;\n        _this._updateInputEl(lc);\n        return lc.repaintLayer('main');\n      };\n    })(this)));\n    return unsubscribeFuncs.push(lc.on('setFont', (function(_this) {\n      return function(font) {\n        if (!_this.currentShape) {\n          return;\n        }\n        _this.font = font;\n        _this.currentShape.setFont(font);\n        _this._setShapesInProgress(lc);\n        _this._updateInputEl(lc);\n        return lc.repaintLayer('main');\n      };\n    })(this)));\n  };\n\n  Text.prototype.willBecomeInactive = function(lc) {\n    if (this.currentShape) {\n      this._ensureNotEditing(lc);\n      this.commit(lc);\n    }\n    return this.unsubscribe();\n  };\n\n  Text.prototype.setText = function(text) {\n    return this.text = text;\n  };\n\n  Text.prototype._ensureNotEditing = function(lc) {\n    if (this.currentShapeState === 'editing') {\n      return this._exitEditingState(lc);\n    }\n  };\n\n  Text.prototype._clearCurrentShape = function(lc) {\n    this.currentShape = null;\n    this.initialShapeBoundingRect = null;\n    this.currentShapeState = null;\n    return lc.setShapesInProgress([]);\n  };\n\n  Text.prototype.commit = function(lc) {\n    if (this.currentShape.text) {\n      lc.saveShape(this.currentShape);\n    }\n    this._clearCurrentShape(lc);\n    return lc.repaintLayer('main');\n  };\n\n  Text.prototype._getSelectionShape = function(ctx, backgroundColor) {\n    if (backgroundColor == null) {\n      backgroundColor = null;\n    }\n    return createShape('SelectionBox', {\n      shape: this.currentShape,\n      ctx: ctx,\n      backgroundColor: backgroundColor\n    });\n  };\n\n  Text.prototype._setShapesInProgress = function(lc) {\n    switch (this.currentShapeState) {\n      case 'selected':\n        return lc.setShapesInProgress([this._getSelectionShape(lc.ctx), this.currentShape]);\n      case 'editing':\n        return lc.setShapesInProgress([this._getSelectionShape(lc.ctx, '#fff')]);\n      default:\n        return lc.setShapesInProgress([this.currentShape]);\n    }\n  };\n\n  Text.prototype.begin = function(x, y, lc) {\n    var br, point, selectionBox, selectionShape;\n    this.dragAction = 'none';\n    this.didDrag = false;\n    if (this.currentShapeState === 'selected' || this.currentShapeState === 'editing') {\n      br = this.currentShape.getBoundingRect(lc.ctx);\n      selectionShape = this._getSelectionShape(lc.ctx);\n      selectionBox = selectionShape.getBoundingRect();\n      point = {\n        x: x,\n        y: y\n      };\n      if (getIsPointInBox(point, br)) {\n        this.dragAction = 'move';\n      }\n      if (getIsPointInBox(point, selectionShape.getBottomRightHandleRect())) {\n        this.dragAction = 'resizeBottomRight';\n      }\n      if (getIsPointInBox(point, selectionShape.getTopLeftHandleRect())) {\n        this.dragAction = 'resizeTopLeft';\n      }\n      if (getIsPointInBox(point, selectionShape.getBottomLeftHandleRect())) {\n        this.dragAction = 'resizeBottomLeft';\n      }\n      if (getIsPointInBox(point, selectionShape.getTopRightHandleRect())) {\n        this.dragAction = 'resizeTopRight';\n      }\n      if (this.dragAction === 'none' && this.currentShapeState === 'editing') {\n        this.dragAction = 'stop-editing';\n        this._exitEditingState(lc);\n      }\n    } else {\n      this.color = lc.getColor('primary');\n      this.currentShape = createShape('Text', {\n        x: x,\n        y: y,\n        text: this.text,\n        color: this.color,\n        font: this.font,\n        v: 1\n      });\n      this.dragAction = 'place';\n      this.currentShapeState = 'selected';\n    }\n    if (this.dragAction === 'none') {\n      this.commit(lc);\n      return;\n    }\n    this.initialShapeBoundingRect = this.currentShape.getBoundingRect(lc.ctx);\n    this.dragOffset = {\n      x: x - this.initialShapeBoundingRect.x,\n      y: y - this.initialShapeBoundingRect.y\n    };\n    this._setShapesInProgress(lc);\n    return lc.repaintLayer('main');\n  };\n\n  Text.prototype[\"continue\"] = function(x, y, lc) {\n    var br, brBottom, brRight;\n    if (this.dragAction === 'none') {\n      return;\n    }\n    br = this.initialShapeBoundingRect;\n    brRight = br.x + br.width;\n    brBottom = br.y + br.height;\n    switch (this.dragAction) {\n      case 'place':\n        this.currentShape.x = x;\n        this.currentShape.y = y;\n        this.didDrag = true;\n        break;\n      case 'move':\n        this.currentShape.x = x - this.dragOffset.x;\n        this.currentShape.y = y - this.dragOffset.y;\n        this.didDrag = true;\n        break;\n      case 'resizeBottomRight':\n        this.currentShape.setSize(x - (this.dragOffset.x - this.initialShapeBoundingRect.width) - br.x, y - (this.dragOffset.y - this.initialShapeBoundingRect.height) - br.y);\n        break;\n      case 'resizeTopLeft':\n        this.currentShape.setSize(brRight - x + this.dragOffset.x, brBottom - y + this.dragOffset.y);\n        this.currentShape.setPosition(x - this.dragOffset.x, y - this.dragOffset.y);\n        break;\n      case 'resizeBottomLeft':\n        this.currentShape.setSize(brRight - x + this.dragOffset.x, y - (this.dragOffset.y - this.initialShapeBoundingRect.height) - br.y);\n        this.currentShape.setPosition(x - this.dragOffset.x, this.currentShape.y);\n        break;\n      case 'resizeTopRight':\n        this.currentShape.setSize(x - (this.dragOffset.x - this.initialShapeBoundingRect.width) - br.x, brBottom - y + this.dragOffset.y);\n        this.currentShape.setPosition(this.currentShape.x, y - this.dragOffset.y);\n    }\n    this._setShapesInProgress(lc);\n    lc.repaintLayer('main');\n    return this._updateInputEl(lc);\n  };\n\n  Text.prototype.end = function(x, y, lc) {\n    if (!this.currentShape) {\n      return;\n    }\n    this.currentShape.setSize(this.currentShape.forcedWidth, 0);\n    if (this.currentShapeState === 'selected') {\n      if (this.dragAction === 'place' || (this.dragAction === 'move' && !this.didDrag)) {\n        this._enterEditingState(lc);\n      }\n    }\n    this._setShapesInProgress(lc);\n    lc.repaintLayer('main');\n    return this._updateInputEl(lc);\n  };\n\n  Text.prototype._enterEditingState = function(lc) {\n    var onChange;\n    this.currentShapeState = 'editing';\n    if (this.inputEl) {\n      throw \"State error\";\n    }\n    this.inputEl = document.createElement('textarea');\n    this.inputEl.className = 'text-tool-input';\n    this.inputEl.style.position = 'absolute';\n    this.inputEl.style.transformOrigin = '0px 0px';\n    this.inputEl.style.backgroundColor = 'transparent';\n    this.inputEl.style.border = 'none';\n    this.inputEl.style.outline = 'none';\n    this.inputEl.style.margin = '0';\n    this.inputEl.style.padding = '4px';\n    this.inputEl.style.zIndex = '1000';\n    this.inputEl.style.overflow = 'hidden';\n    this.inputEl.style.resize = 'none';\n    this.inputEl.value = this.currentShape.text;\n    this.inputEl.addEventListener('mousedown', function(e) {\n      return e.stopPropagation();\n    });\n    this.inputEl.addEventListener('touchstart', function(e) {\n      return e.stopPropagation();\n    });\n    onChange = (function(_this) {\n      return function(e) {\n        _this.currentShape.setText(e.target.value);\n        _this.currentShape.enforceMaxBoundingRect(lc);\n        _this._setShapesInProgress(lc);\n        lc.repaintLayer('main');\n        _this._updateInputEl(lc);\n        return e.stopPropagation();\n      };\n    })(this);\n    this.inputEl.addEventListener('keydown', (function(_this) {\n      return function() {\n        return _this._updateInputEl(lc, true);\n      };\n    })(this));\n    this.inputEl.addEventListener('keyup', onChange);\n    this.inputEl.addEventListener('change', onChange);\n    this._updateInputEl(lc);\n    lc.containerEl.appendChild(this.inputEl);\n    this.inputEl.focus();\n    return this._setShapesInProgress(lc);\n  };\n\n  Text.prototype._exitEditingState = function(lc) {\n    this.currentShapeState = 'selected';\n    lc.containerEl.removeChild(this.inputEl);\n    this.inputEl = null;\n    this._setShapesInProgress(lc);\n    return lc.repaintLayer('main');\n  };\n\n  Text.prototype._updateInputEl = function(lc, withMargin) {\n    var br, transformString;\n    if (withMargin == null) {\n      withMargin = false;\n    }\n    if (!this.inputEl) {\n      return;\n    }\n    br = this.currentShape.getBoundingRect(lc.ctx, true);\n    this.inputEl.style.font = this.currentShape.font;\n    this.inputEl.style.color = this.currentShape.color;\n    this.inputEl.style.left = (lc.position.x / lc.backingScale + br.x * lc.scale - 4) + \"px\";\n    this.inputEl.style.top = (lc.position.y / lc.backingScale + br.y * lc.scale - 4) + \"px\";\n    if (withMargin && !this.currentShape.forcedWidth) {\n      this.inputEl.style.width = (br.width + 10 + this.currentShape.renderer.emDashWidth) + \"px\";\n    } else {\n      this.inputEl.style.width = (br.width + 12) + \"px\";\n    }\n    if (withMargin) {\n      this.inputEl.style.height = (br.height + 10 + this.currentShape.renderer.metrics.leading) + \"px\";\n    } else {\n      this.inputEl.style.height = (br.height + 10) + \"px\";\n    }\n    transformString = \"scale(\" + lc.scale + \")\";\n    this.inputEl.style.transform = transformString;\n    this.inputEl.style.webkitTransform = transformString;\n    this.inputEl.style.MozTransform = transformString;\n    this.inputEl.style.msTransform = transformString;\n    return this.inputEl.style.OTransform = transformString;\n  };\n\n  Text.prototype.optionsStyle = 'font';\n\n  return Text;\n\n})(Tool);\n\n\n},{\"../core/shapes\":17,\"./base\":53}],53:[function(require,module,exports){\nvar Tool, ToolWithStroke, tools,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\ntools = {};\n\ntools.Tool = Tool = (function() {\n  function Tool() {}\n\n  Tool.prototype.name = null;\n\n  Tool.prototype.iconName = null;\n\n  Tool.prototype.usesSimpleAPI = true;\n\n  Tool.prototype.begin = function(x, y, lc) {};\n\n  Tool.prototype[\"continue\"] = function(x, y, lc) {};\n\n  Tool.prototype.end = function(x, y, lc) {};\n\n  Tool.prototype.optionsStyle = null;\n\n  Tool.prototype.didBecomeActive = function(lc) {};\n\n  Tool.prototype.willBecomeInactive = function(lc) {};\n\n  return Tool;\n\n})();\n\ntools.ToolWithStroke = ToolWithStroke = (function(superClass) {\n  extend(ToolWithStroke, superClass);\n\n  function ToolWithStroke(lc) {\n    this.strokeWidth = lc.opts.defaultStrokeWidth;\n  }\n\n  ToolWithStroke.prototype.optionsStyle = 'stroke-width';\n\n  ToolWithStroke.prototype.didBecomeActive = function(lc) {\n    var unsubscribeFuncs;\n    unsubscribeFuncs = [];\n    this.unsubscribe = (function(_this) {\n      return function() {\n        var func, i, len, results;\n        results = [];\n        for (i = 0, len = unsubscribeFuncs.length; i < len; i++) {\n          func = unsubscribeFuncs[i];\n          results.push(func());\n        }\n        return results;\n      };\n    })(this);\n    return unsubscribeFuncs.push(lc.on('setStrokeWidth', (function(_this) {\n      return function(strokeWidth) {\n        _this.strokeWidth = strokeWidth;\n        return lc.trigger('toolDidUpdateOptions');\n      };\n    })(this)));\n  };\n\n  ToolWithStroke.prototype.willBecomeInactive = function(lc) {\n    return this.unsubscribe();\n  };\n\n  return ToolWithStroke;\n\n})(Tool);\n\nmodule.exports = tools;\n\n\n},{}]},{},[22])(22)\n});\n"},JPcO:function(n,e,t){t("P+fo")(t("+JOu"))},"P+fo":function(n,e){n.exports=function(n){"undefined"!=typeof execScript?execScript(n):eval.call(null,n)}},"yQ/E":function(n,e,t){t("P+fo")(t("4Cf4"))}},[3]);